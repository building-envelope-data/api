"""
Read-only GraphQL schema for databases that store measurement and simulation
data in various formats and refer to the "metabase" for meta information like
data format specifications.

It follows best practices for
* [Global Object Identification](https://graphql.org/learn/global-object-identification/)
  as exemplified in
  [GraphQL Server Specification: Object Identification](https://relay.dev/docs/en/graphql-server-specification.html#object-identification)
  (see also [GraphQL Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)),
  and
* [Pagination](https://graphql.org/learn/pagination/),
  by adhering to the
  [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
  as exemplified in
  [GraphQL Server Specification: Connections](https://relay.dev/docs/en/graphql-server-specification.html#connections).

Global object identifiers as requird by the best practice are exposed by the
property `id` and universally unique identifiers as issued by the "metabase"
are exposed by the property `dataId`. In essence, `id` is the Base64-encoded
concatenation of `dataId` and the requested locale.

For interoperability with the "metabase", implementations must serve HTTP
requests as elaborated on
[Serving over HTTP](https://graphql.org/learn/serving-over-http/).

The
[Internet Engineering Task Force (IETF)](https://www.ietf.org)
is an Internet standards organization. It publishes standards in
[Request for Comments (RFC)](https://ietf.org/standards/rfcs/)
documents. They are
[searchable](https://www.rfc-editor.org/search/rfc_search.php)
and
[indexed](https://www.rfc-editor.org/rfc-index.html).
Examples are
[Hypertext Transfer Protocol (HTTP)](https://tools.ietf.org/html/rfc7231)
and
[Transport Layer Security (TLS)](https://tools.ietf.org/html/rfc8446).

The
[Internet Assigned Numbers Authority (IANA)](https://www.iana.org)
allocates and maintains unique codes and numbering systems that are used in
technical standards that drive the Internet like
[domain names](https://www.iana.org/domains),
[Internet Protocol addresses](https://www.iana.org/numbers), and
[registries](https://www.iana.org/protocols).
Examples of the last are
[HTTP status code registry](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)
and
[media type registry](https://www.iana.org/assignments/media-types/media-types.xhtml).

The
[International Organization for Standardization (ISO)](https://www.iso.org)
develops and publishes
[International Standards](https://www.iso.org/standards-catalogue/browse-by-ics.html).
Examples are
[ISO 8601 Date And Time Format](https://www.iso.org/iso-8601-date-and-time-format.html)
and
[ISO 3166 Country Codes](https://www.iso.org/iso-3166-country-codes.html).

The library
[graphql-scalars](https://github.com/Urigo/graphql-scalars)
introduces custom scalar types for creating precise type-safe GraphQL schemas.
We took some inspiration from
[GitHub GraphQL API](https://docs.github.com/en/graphql).
"""
scalar Schema

schema {
  query: Query
}

"""
[RFC 4122](https://tools.ietf.org/html/rfc4122)
compliant
[non-nil](https://tools.ietf.org/html/rfc4122#section-4.1.7)
[Universally Unique Identifier (UUID)](https://tools.ietf.org/html/rfc4122#section-4.1)
string represented as 32 hexadecimal digits in five groups separated by hyphens
in the form `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`, like
`"936da01f-9abd-4d9d-80c7-02af85c822a8"`. Such identifiers are not equal to
`"00000000-0000-0000-0000-000000000000"` and match the regular expression
`^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$`.
"""
scalar Uuid

"""
[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)
encoded date and time string with offset from Coordinated Universal Time (UTC),
where the fraction of a second permits at most 6 digits. For example, in UTC it
may be in the form `yyyy-MM-ddTHH:mm:ss.ffffffZ`, like
`"2009-06-15T13:45:30.381739Z"`, and in local time in the form
`yyyy-MM-ddTHH:mm:ss.ffffffzzz`, like `"2009-06-15T13:45:30.381739-07:00"`.

Note that
[RFC 3339](https://tools.ietf.org/html/rfc3339)
is a profile of the ISO 8601 standard for representation of dates and times
using the Gregorian calendar.
"""
scalar DateTime

"""
[RFC 3986](https://tools.ietf.org/html/rfc3986)
and
[RFC 3987](https://tools.ietf.org/html/rfc3987)
compliant
[absolute Uniform Resource Locator (URL)](https://tools.ietf.org/html/rfc3986#section-4.3)
string with optional
[fragment identifier](https://tools.ietf.org/html/rfc3986#section-3.5).

See also
[URL Living Standard](https://url.spec.whatwg.org/#absolute-url-with-fragment-string)
and
[Identifying resources on the Web](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web).
"""
scalar Url

"""
[BCP 47](https://tools.ietf.org/html/bcp47)
compliant
[Language Tag](https://tools.ietf.org/html/bcp47#section-2)
string like `"de-AT"`, `"sr-Latn-RS"`, `"en-US"`, or `"en-GB"`, where the language
part is essentially an
[ISO 639 Language Code](https://www.iso.org/iso-639-language-codes.html),
the script an
[ISO 15924:2004 Script Code](https://www.iso.org/standard/29546.html),
and the region an
[ISO 3166-1 Country Code](https://www.iso.org/iso-3166-country-codes.html).

Note that the
[Internet Assigned Numbers Authority (IANA)](https://www.iana.org)
maintains the
[Language Subtag Registry](https://www.iana.org/assignments/lang-subtags-templates/lang-subtags-templates.xhtml).
"""
scalar Locale

"""
[June 2018 GraphQL](http://spec.graphql.org/June2018/)
compliant
[query](http://spec.graphql.org/June2018/#sec-Language.Operations)
string without
[variables](http://spec.graphql.org/June2018/#sec-Language.Variables)
and without unnecessary white-space for the present schema.
"""
scalar GraphQlQuery

"""
[June 2018 GraphQL](http://spec.graphql.org/June2018/)
compliant
[JavaScript Object Notation (JSON)](https://tools.ietf.org/html/rfc8259)
[serialized](http://spec.graphql.org/June2018/#sec-JSON-Serialization)
[response](http://spec.graphql.org/June2018/#sec-Response)
string without unnecessary white-space for the present schema.
"""
scalar JsonGraphQlResponse

"""
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
compliant
[Cursor](https://relay.dev/graphql/connections.htm#sec-Cursor)
string.
"""
scalar Cursor

"""
Non-negative integer
"""
scalar NonNegativeInt

"""
Anything
"""
scalar Any

"""
Fetch data, ask whether there is data, and search for data. Each field except
`node` accepts
- an optional timestamp to specify for which point in time the query is to be
  made and
- an optional locale to specify essentially the language of prose in the result.
Each field's value is uniquely determined by the required arguments,
timestamp, and locale throughout time.

If timestamp is not given, the moment the query is received is used. And, if
locale is not given, the default locale is used, which may differ from database
to database.
"""
type Query {
  """
  Fetch node by global object identifier as elaborated on
  [Global Object Identification](https://graphql.org/learn/global-object-identification/)
  where two nodes with identical identifiers must be equal as elaborated in
  [Field stability](https://graphql.org/learn/global-object-identification/#field-stability).

  See also
  [Node root field](https://graphql.org/learn/global-object-identification/#node-root-field)
  """
  node(id: ID!): Node!

  """
  Fetch data by universally unique identifier, and optional timestamp and
  locale, where all three arguments together uniquely determine the data
  throughout time.
  """
  data(
    dataId: Uuid!,
    "If not given, the moment the query is received is used."
    timestamp: DateTime,
    "If not given, the default locale is used, which may differ from database to database."
    locale: Locale
  ): Data!

  """
  See `Query#data`.
  """
  calorimetricData(
    calorimetricDataId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): CalorimetricData!

  """
  See `Query#data`.
  """
  hygrothermalData(
    hygrothermalDataId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): HygrothermalData!

  """
  See `Query#data`.
  """
  opticalData(
    opticalDataId: Uuid!,
    timestamp: DateTime,
    locale: Locale
  ): OpticalData!

  """
  See `Query#data`.
  """
  photovoltaicData(
    photovoltaicDataId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): PhotovoltaicData!

  """
  Search for all data for which the proposition is true.

  The result is a
  [connection](https://relay.dev/graphql/connections.htm#sec-Connection-Types)
  with
  [edges](https://relay.dev/graphql/connections.htm#sec-Edge-Types)
  and
  [nodes](https://relay.dev/graphql/connections.htm#sec-Node)
  as specified in the
  [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
  where the nodes are the actual data, and connection and edges are used for
  meta information and
  [pagination](https://graphql.org/learn/pagination/)
  together with the
  [forward pagination arguments](https://relay.dev/graphql/connections.htm#sec-Forward-pagination-arguments)
  `first` and `after` and the
  [backward pagination arguments](https://relay.dev/graphql/connections.htm#sec-Backward-pagination-arguments)
  `last` and `before`.

  Example:
  ```
  query {
    allData(
      where: {
        or: [
          {
            componentId: "810e84b4-9ebf-416c-88ea-aade848f1fdf",
            gValue: { greaterThanOrEqualTo: 0.5 },
            not: {
              uValue: { lessThanOrEqualTo: 0.5 }
            }
          },
          {
            nearnormalHemisphericalVisibleTransmittance: {
              inClosedInterval: {
                lowerBound: 0.2,
                upperBound: 0.8
              }
            }
          }
        ]
      }
    ): {
      edges {
        node {
          dataId
        }
      }
    }
  }
  ```
  """
  allData(
    where: DataPropositionInput!
    "If not given, the moment the query is received is used."
    timestamp: DateTime
    "If not given, the default locale is used, which may differ from database to database."
    locale: Locale
    "Maximum number of data edges after the cursor `after`."
    first: NonNegativeInt
    "Data cursor after which to return at most `first` data edges."
    after: Cursor
    "Maximum number of data edges before the cursor `before`."
    last: NonNegativeInt
    "Data cursor before which to return at most `last` data edges."
    before: Cursor
  ): DataConnection

  """
  See `Query#allData`.
  """
  allCalorimetricData(
    where: CalorimetricDataPropositionInput!
    timestamp: DateTime
    locale: Locale
    first: NonNegativeInt
    after: Cursor
    last: NonNegativeInt
    before: Cursor
  ): CalorimetricDataConnection

  """
  See `Query#allData`.
  """
  allHygrothermalData(
    where: HygrothermalDataPropositionInput!
    timestamp: DateTime
    locale: Locale
    first: NonNegativeInt
    after: Cursor
    last: NonNegativeInt
    before: Cursor
  ): HygrothermalDataConnection

  """
  See `Query#allData`.
  """
  allOpticalData(
    where: OpticalDataPropositionInput!
    timestamp: DateTime
    locale: Locale
    first: NonNegativeInt
    after: Cursor
    last: NonNegativeInt
    before: Cursor
  ): OpticalDataConnection

  """
  See `Query#allData`.
  """
  allPhotovoltaicData(
    where: PhotovoltaicDataPropositionInput!
    timestamp: DateTime
    locale: Locale
    first: NonNegativeInt
    after: Cursor
    last: NonNegativeInt
    before: Cursor
  ): PhotovoltaicDataConnection

  """
  Whether there is data for the component with the given universally unique
  identifier at the given timestamp in the given locale.
  """
  hasData(
    componentId: Uuid!,
    "If not given, the moment the query is received is used."
    timestamp: DateTime
    "If not given, the default locale is used, which may differ from database to database."
    locale: Locale
  ): Boolean!

  """
  See `Query#hasData`.
  """
  hasCalorimetricData(
    componentId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): Boolean!

  """
  See `Query#hasData`.
  """
  hasHygrothermalData(
    componentId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): Boolean!

  """
  See `Query#hasData`.
  """
  hasOpticalData(
    componentId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): Boolean!

  """
  See `Query#hasData`.
  """
  hasPhotovoltaicData(
    componentId: Uuid!
    timestamp: DateTime
    locale: Locale
  ): Boolean!
}

"""
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
and
[Global Object Identification](https://graphql.org/learn/global-object-identification/)
compliant
[Node](https://relay.dev/graphql/connections.htm#sec-Node)
interface.

See also
[Node](https://graphql.org/learn/global-object-identification/#node-interface).

Note that according to
[Field stability](https://graphql.org/learn/global-object-identification/#field-stability),
if two objects appear in a query, both implementing `Node` with identical
identifiers, then the two objects must be equal. For example, for queried data,
the identifier could be a Base64-encoded concatenation of the data identifier,
which is a `Uuid`, and the requested locale.
"""
interface Node {
  """
  Base64-encoded identifier.
  """
  id: ID!
}

"""
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
compliant
[PageInfo](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo)
type.

Note that although the introspection query results on
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
use the scalar type `String` for cursors, the specification of
[cursors](https://relay.dev/graphql/connections.htm#sec-Cursor)
says that a cursor must only be of
> a type that serializes as a `String`; this may be a `String`, a non‐null
> wrapper around a `String`, a custom scalar that serializes as a `String`, or
> a non‐null wrapper around a custom scalar that serializes as a `String`.
"""
type PageInfo {
  """
  Whether more edges exist following the set defined by the client's arguments.
  For details see
  [PageInfo: Fields](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo.Fields).
  """
  hasNextPage: Boolean!

  """
  Whether more edges exist prior to the set defined by the clients arguments.
  For details see
  [PageInfo: Fields](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo.Fields).
  """
  hasPreviousPage: Boolean!

  """
  Cursor corresponding to the first edge in the set defined by the client's
  arguments. For details see
  [PageInfo: Fields](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo.Fields).
  """
  startCursor: Cursor!

  """
  Cursor corresponding to the last edge in the set defined by the client's
  arguments. For details see
  [PageInfo: Fields](https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo.Fields).
  """
  endCursor: Cursor!

  """
  Number of edges in the set defined by the client's arguments. This is equal
  to the number of nodes.
  """
  count: NonNegativeInt!
}

"""
Closed interval from lower to upper bound. Each `Float` `x` is in the interval if
and only if `x` is greater than or equal to the lower bound and less than or
equal to the upper bound. In particular, if the lower bound is equal to the
upper bound, then the interval consists of exactly one float; and, if the lower
bound is greater than the upper bound, then the interval is empty.
"""
input ClosedIntervalInput {
  """
  Lower bound.
  """
  lowerBound: Float!

  """
  Upper bound.
  """
  upperBound: Float!
}

"""
Proposition for values of type `Float`. Multiple sub-propositions are combined
conjunctively.
"""
input FloatPropositionInput {
  """
  True for values that are equal to `equalTo`, otherwise false.
  """
  equalTo: Float

  """
  True for values that are greater than or equal to `greaterThanOrEqualTo`,
  otherwise false.
  """
  greaterThanOrEqualTo: Float

  """
  True for values that are in the closed interval `inClosedInterval`, otherwise
  false.
  """
  inClosedInterval: ClosedIntervalInput

  """
  True for values that are less than or equal to `lessThanOrEqualTo`, otherwise
  false.
  """
  lessThanOrEqualTo: Float
}

"""
Proposition for values of type `Data`. Multiple sub-propositions are combined
conjunctively.
"""
input DataPropositionInput {
  """
  True for data for the component with identifier `componentId`, otherwise
  false.
  """
  componentId: Uuid

  """
  True for data for which each proposition in `and` is true, otherwise false.
  """
  and: [DataPropositionInput!]

  """
  True for data that has a `g` value for which the proposition `gValue` is
  true, otherwise false.
  """
  gValue: FloatPropositionInput

  """
  True for data that has a nearnormal hemispherical visible transmittance value
  for which the proposition `nearnormalHemisphericalVisibleTransmittance` is
  true, otherwise false.
  """
  nearnormalHemisphericalVisibleTransmittance: FloatPropositionInput

  """
  True for data for which the proposition `not` is false, otherwise false.
  """
  not: DataPropositionInput

  """
  True for data for which at least one proposition in `or` is true, otherwise
  false.
  """
  or: [DataPropositionInput!]

  """
  True for data that has a `u` value for which the proposition `uValue` is
  true, otherwise false.
  """
  uValue: FloatPropositionInput
}

"""
See `DataPropositionInput`.
"""
input OpticalDataPropositionInput {
  componentId: Uuid
  and: [OpticalDataPropositionInput!]
  nearnormalHemisphericalVisibleTransmittance: FloatPropositionInput
  not: OpticalDataPropositionInput
  or: [OpticalDataPropositionInput!]
}

"""
See `DataPropositionInput`.
"""
input CalorimetricDataPropositionInput {
  componentId: Uuid
  and: [CalorimetricDataPropositionInput!]
  gValue: FloatPropositionInput
  not: CalorimetricDataPropositionInput
  or: [CalorimetricDataPropositionInput!]
  uValue: FloatPropositionInput
}

"""
See `DataPropositionInput`.
"""
input HygrothermalDataPropositionInput {
  componentId: Uuid
  and: [HygrothermalDataPropositionInput!]
  not: HygrothermalDataPropositionInput
  or: [HygrothermalDataPropositionInput!]
}

"""
See `DataPropositionInput`.
"""
input PhotovoltaicDataPropositionInput {
  componentId: Uuid
  and: [PhotovoltaicDataPropositionInput!]
  not: PhotovoltaicDataPropositionInput
  or: [PhotovoltaicDataPropositionInput!]
}

"""
Materialized connection from somewhere to data to paginate data using opaque
cursors as elaborated in the best practice
[Pagination](https://graphql.org/learn/pagination/)
and the specification
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
see in particular
[Complete Connection Model](https://graphql.org/learn/pagination/#complete-connection-model)
and
[Connection Types](https://relay.dev/graphql/connections.htm#sec-Connection-Types).
"""
type DataConnection {
  """
  Edges to data nodes that expose opaque cursors for pagination.
  """
  edges: [DataEdge!]!

  """
  Data nodes to avoid the layer of indirection through edges in case edge meta
  data is not needed. It is equal to the array comprehension
  ```
  [edge.node for edge in edges]
  ```
  """
  nodes: [Data!]!

  """
  Total number of data edges (and nodes) of which a slice is `edges` (and
  `nodes`). Note that the number of edges (and nodes) of the present slice is
  `pageInfo.count`.
  """
  totalCount: NonNegativeInt!

  """
  Information about the present slice of all data edges (and nodes).
  """
  pageInfo: PageInfo!

  """
  Timestamp at or for which the connection, its edges and nodes are returned.
  In case no timestamp was given as argument, this is the moment in time the
  query was made. Otherwise, it is the given timestamp. All data edges and
  nodes are fetched as they were at this timestamp.
  """
  timestamp: DateTime!
}

"""
Materialized edge from somewhere to data to paginate data using opaque
cursors as elaborated in the best practice
[Pagination](https://graphql.org/learn/pagination/)
and the specification
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
see in particular
[Complete Connection Model](https://graphql.org/learn/pagination/#complete-connection-model)
and
[Edge Types](https://relay.dev/graphql/connections.htm#sec-Edge-Types).
"""
type DataEdge {
  """
  Opaque
  [cursor](https://relay.dev/graphql/connections.htm#sec-Cursor)
  that designates the present edge for pagination.
  """
  cursor: Cursor!

  """
  Data node the edge points to.
  """
  node: Data!
}

"""
See `DataConnection`.
"""
type OpticalDataConnection {
  edges: [OpticalDataEdge!]!
  nodes: [OpticalData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
}

"""
See `DataEdge`.
"""
type OpticalDataEdge {
  cursor: Cursor!
  node: OpticalData!
}

"""
See `DataConnection`.
"""
type HygrothermalDataConnection {
  edges: [HygrothermalDataEdge!]!
  nodes: [HygrothermalData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
}

"""
See `DataEdge`.
"""
type HygrothermalDataEdge {
  cursor: Cursor!
  node: HygrothermalData!
}

"""
See `DataConnection`.
"""
type PhotovoltaicDataConnection {
  edges: [PhotovoltaicDataEdge!]!
  nodes: [PhotovoltaicData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
}

"""
See `DataEdge`.
"""
type PhotovoltaicDataEdge {
  cursor: Cursor!
  node: PhotovoltaicData!
}

"""
See `DataConnection`.
"""
type CalorimetricDataConnection {
  edges: [CalorimetricDataEdge!]!
  nodes: [CalorimetricData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
}

"""
See `DataEdge`.
"""
type CalorimetricDataEdge {
  cursor: Cursor!
  node: CalorimetricData!
}

"""
Measured, simulated, or calculated data.
"""
interface Data {
  """
  Identifier, which together with timestamp uniquely identifies data and
  version (within the database).
  """
  dataId: Uuid!

  """
  Timestamp that designates the version. For example, correction of some
  grammatical error in the description results in a new version designated by
  a new timestamp, or adding an approval by some stakeholder.
  """
  timestamp: DateTime!

  """
  Component identifier issued by the metabase. The components's meta data can
  be obtained by sending the GraphQL query
  `component(componentId: ..., timestamp: ...) { ... }`
  to the metabase.
  """
  componentId: Uuid!

  """
  Name
  """
  name: String

  """
  Description
  """
  description: String

  """
  Critical information to avoid mistakes due to data misinterpretation.
  """
  warnings: [String!]!

  """
  Creator identifier issued by the metabase. The creator's meta data can be
  obtained by sending the GraphQL query
  `stakeholder(stakeholderId: ..., timestamp: ...) { ... }`
  to the metabase.
  """
  creatorId: Uuid!

  """
  Creation timestamp
  """
  creationTimestamp: DateTime!

  """
  Method that was applied to create this data set.
  """
  appliedMethod: AppliedMethod!

  """
  Validity date and time range
  """
  validity: OpenEndedDateTimeRange!

  """
  Approvals by stakeholders in the form of GnuPG signatures. To verify
  signatures you need all signed data. It is thus advisable to include all
  fields in the query. For verification you can then temporarily remove the
  fields that are not signed. See the type `Approval` for details.
  """
  approvals: [Approval!]!

  """
  Multiple HTTP resources with meta information of the actual data requestable
  through the protocol HTTP over TLS, in short, HTTPS, with `GET` requests. The
  first resource's data is the result of applying the method `appliedMethod`.
  The other resources' data is the result of applying some conversion method or
  a chain of such methods to the first resource's data. Detailed information
  about which conversion method applied to which data resulted in which other
  data is recorded in the tree with the root `resourceRoot`.

  Note that all resources describe the same data only in different formats.
  """
  resources: [GetHttpsResource!]!

  """
  Root vertex made up of
  * an HTTP resource with meta information of the actual data
    requestable through the protocol HTTP over
    TLS, in short, HTTPS, with `GET` requests, where the data is
    the result of applying
    the method `appliedMethod`, and
  * child vertices, where each child vertex is made up of an HTTP resource whose
    data is the result of applying some conversion method to the root's data,
    child vertices of itself, and the applied conversion method.

  By traversing the tree from the root at each vertex it is clear how its data
  was obtained from its parent's data.

  Note that all resources describe the same data only in different formats.
  """
  resourceRoot: GetHttpsResourceRoot!

  """
  Approval by the database of the result without the field `approval` itself.
  """
  approval: ResponseApproval!

  """
  Locale of text
  """
  locale: Locale
}

type OpticalData implements Node & Data {
  id: ID!
  dataId: Uuid!
  timestamp: DateTime!
  locale: Locale
  databaseId: Uuid!
  componentId: Uuid!
  name: String
  description: String
  warnings: [String!]!
  creatorId: Uuid!
  creationTimestamp: DateTime!
  appliedMethod: AppliedMethod!
  validity: OpenEndedDateTimeRange!
  resources: [GetHttpsResource!]!
  resourceRoot: GetHttpsResourceRoot!
  approvals: [DataApproval!]!
  approval: ResponseApproval!

  """
  Mirrored nearnormal hemispherical visible transmittance values that occur in
  the data
  """
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
}

type CalorimetricData implements Node & Data {
  id: ID!
  dataId: Uuid!
  timestamp: DateTime!
  locale: Locale
  databaseId: Uuid!
  componentId: Uuid!
  name: String
  description: String
  warnings: [String!]!
  creatorId: Uuid!
  creationTimestamp: DateTime!
  appliedMethod: AppliedMethod!
  validity: OpenEndedDateTimeRange!
  resources: [GetHttpsResource!]!
  resourceRoot: GetHttpsResourceRoot!
  approvals: [DataApproval!]!
  approval: ResponseApproval!

  """
  Mirrored `g` values that occur in the data
  """
  gValues: [Float!]!

  """
  Mirrored `u` values that occur in the data
  """
  uValues: [Float!]!
}

type HygrothermalData implements Node & Data {
  id: ID!
  dataId: Uuid!
  timestamp: DateTime!
  locale: Locale
  databaseId: Uuid!
  componentId: Uuid!
  name: String
  description: String
  warnings: [String!]!
  creatorId: Uuid!
  creationTimestamp: DateTime!
  appliedMethod: AppliedMethod!
  validity: OpenEndedDateTimeRange!
  resources: [GetHttpsResource!]!
  resourceRoot: GetHttpsResourceRoot!
  approvals: [DataApproval!]!
  approval: ResponseApproval!
}

type PhotovoltaicData implements Node & Data {
  id: ID!
  dataId: Uuid!
  timestamp: DateTime!
  locale: Locale
  databaseId: Uuid!
  componentId: Uuid!
  name: String
  description: String
  warnings: [String!]!
  creatorId: Uuid!
  creationTimestamp: DateTime!
  appliedMethod: AppliedMethod!
  validity: OpenEndedDateTimeRange!
  resources: [GetHttpsResource!]!
  resourceRoot: GetHttpsResourceRoot!
  approvals: [DataApproval!]!
  approval: ResponseApproval!
}

type AppliedMethod {
  """
  Method identifier of method that was applied by the creator on the source
  data. The method's meta data can be obtained by sending the GraphQL query
  `method(methodId: ..., timestamp: ...) { ... }`
  to the metabase.
  """
  methodId: Uuid!

  """
  Named parameters to configure the method.
  """
  parameters: [MethodParameter!]!

  """
  Named data sources to which the method was applied.
  """
  sourceIds: [MethodSource!]!
}

"""
An applied method whose sources are implicit from the context in which it is
used.
"""
type AppliedMethodWithImplicitSources {
  """
  Method identifier of method that was applied by the creator on the source
  data. The method's meta data can be obtained by sending the GraphQL query
  `method(methodId: ..., timestamp: ...) { ... }`
  to the metabase.
  """
  methodId: Uuid!

  """
  Named parameters to configure the method.
  """
  parameters: [MethodParameter!]!
}

type MethodParameter {
  name: String!
  value: Any!
}

type MethodSource {
  name: String!
  value: CrossDatabaseReference!
}

type CrossDatabaseReference {
  dataId: Uuid!
  dataKind: DataKind!
  databaseId: Uuid!
}

enum DataKind {
  CALORIMETRIC_DATA
  HYGROTHERMAL_DATA
  OPTICAL_DATA
  PHOTOVOLTAIC_DATA
}

"""
Open-ended data and time range
"""
type OpenEndedDateTimeRange {
  """
  From beginning of time represented by `null`, or some date and time
  """
  from: DateTime

  """
  Until some date and time, or end of time represented by `null`
  """
  until: DateTime
}

"""
Approval with
[GnuPG](https://www.gnupg.org)
signature.

To verify an approval,
1. install [GnuPG](https://www.gnupg.org),
2. save the approved response in a file `response.json`,
3. save the ASCII-armored signature in a file `response.json.asc`,
4. * retrieve the public key for the given fingerprint from the metabase's
     keyserver by running
     `gpg --keyserver keyserver.buildingenvelopedata.org --recv-keys <FINGERPRINT>`
     (or
     `gpg --fetch-keys https://buildingenvelopedata.org/gnuPgKey/<FINGERPRINT>.asc`)
     and make sure that the key belongs to the approver, was allowed for
     signing, and was valid at a given timestamp by sending a request of the
     form
     ```
     database(databaseId: ..., timestamp: <TIMESTAMP>) {
       hasGnuPgKey(fingerprint: <FINGERPRINT>, status: ALLOWED, valid: true)
     }
     ```
     or
     ```
     stakeholder(stakeholderId: ..., timestamp: <TIMESTAMP>) {
       hasGnuPgKey(fingerprint: <FINGERPRINT>, status: ALLOWED, valid: true)
     }
     ```
   * or retrieve the allowed-for-signing and valid-at-the-given-time key from
     the metabase's GraphQL endpoint by sending a request of the form
     ```
     database(databaseId: ..., timestamp: <TIMESTAMP>) {
       gnuPgKey(fingerprint: <FINGERPRINT>, status: ALLOWED, valid: true)
     }
     ```
     or
     ```
     stakeholder(stakeholderId: ..., timestamp: <TIMESTAMP>) {
       gnuPgKey(fingerprint: <FINGERPRINT>, status: ALLOWED, valid: true)
     }
     ```
     save the ASCII-armored key in a file `my.gpg.asc`, and import it by running
     `gpg --import ./my.gpg.asc`.
   where `<TIMESTAMP>` is the timestamp at which the approval was created (for
   response approvals this is the timestamp of the response).
5. verify the signature with the public key by running
   `gpg --verify response.json.asc response.json`.

To create an approval,
1. install [GnuPG](https://www.gnupg.org),
2. create a master key by running
   `gpg --full-generate-key`,
   selecting option `3. DSA (sign only)`,
   choosing the keysize `2048`,
   setting the validity `2y = key expires in 2 years`, and
   answering all subsequent questions in particular adding a strong passphrase.
3. create a signing subkey by running
   `gpg --edit-key <YOUR_EMAIL_ADDRESS>`,
   entering the command `addkey`
   selecting option `(3) DSA (sign only)`,
   choosing the keysize `2048`,
   setting the validity `2y = key expires in 2 years`, and
   answering all subsequent questions, and
   entering the command `save`.
4. list your keys with fingerprints by running
   `gpg --list-keys --with-subkey-fingerprint <YOUR_EMAIL_ADDRESS>`.
5. add your signing key to the metabase by exporting it with
   `gpg --export --armor --output key.asc <SIGNING_KEY_FINGERPRINT>`
   and uploading it with
   `TODO Use keyserver and email addresses, or GraphQL endpoints`,
6. save the response to be approved in a file `response.json`,
7. compute the signature and write it to `response.json.asc` by running
   `gpg --detach-sig --armor --local-user <SIGNING_KEY_FINGERPRINT> response.json`, and
8. add the signature as approval to the database through its interface.

Best practices for managing GnuPG keys within an institution:
* In the metabase, each institution has at least one representative and the
  institution's GnuPG keys are but the keys of all its representatives.
* Each representative of an institution within the metabase who is allowed to
  approve data for its institution adds its signing key to the metabase and its
  keyserver (both are coupled and one cannot be done without the other) either
  with the GraphQL mutation
  ```
  TODO add code example
  ```
  or by running
  `gpg --keyserver keyserver.buildingenvelopedata.org --send-keys <SIGNING_KEY_FINGERPRINT>`
  TODO This does actually not work because the representative needs to authenticate herself. How can this be accomplished? Can we send an access token?
* When a representative's signing subkey is compromised she revokes it as
  described in
  [Revoking key components](https://www.gnupg.org/gph/en/manual.html#AEN305)
  and publishes the revocation either with the corresponding GraphQL mutation
  ```
  TODO add code example
  ```
  or by running
  `gpg --keyserver keyserver.buildingenvelopedata.org --send-key <SIGNING_KEY_FINGERPRINT>`.
  TODO As above this does not work because of missing authentication.
* When a representative leaves a company or is no longer allowed to approve data,
  the metabase it informed about that with the GraphQL mutation
  ```
  TODO add code example
  ```

Best practices for accepting approvals by databases:
* Check that the fingerprint belongs to a non-revoked and valid GnuPG key of an
  active representative of an institution who is allowed to make signatures for
  that institution.
* Check that the query contains all necessary fields and sub-fields and
  specifies a timestamp.
* Check that the response is the result of the given query.
* Check that the signature is valid for the given response.
TODO Add GraphQL examples where possible.

Note that GnuPG is compliant with
[OpenPGP Message Format](https://tools.ietf.org/html/rfc4880).

For an introduction to GnuPG consult
[The GNU Privacy Handbook](https://www.gnupg.org/gph/en/manual.html)
or the article series
[Getting started with GPG (GnuPG)](https://www.redhat.com/sysadmin/getting-started-gpg),
[How to create GPG keypairs](https://www.redhat.com/sysadmin/creating-gpg-keypairs), and
[Digital signatures with GnuPG](https://www.redhat.com/sysadmin/digital-signatures-gnupg).
.
"""
interface Approval {
  """
  Detached ASCII-armored GnuPG signature.

  With the query response saved in the file `response.json`, the signature can
  be computed and written to `response.json.asc` by running
  `gpg --detach-sig --armor response.json`
  (to write it to standard output instead, add the option `--output -`). And,
  the signature can be verified by running
  `gpg --verify response.json.asc response.json`.
  Note that to compute a signature you need a GnuPG signing private key in your
  key ring and to verify a signature you need the GnuPG signing public key
  whose corresponding private key was used to compute the signature.
  """
  signature: String!

  """
  Fingerprint of the GnuPG signing key used to compute the signature.

  The key's fingerprint, long identifier, and short identifier are related as
  in the follow example:
  * fingerprint: 0D69 E11F 12BD BA07 7B37  26AB 4E1F 799A A4FF 2279
  * long id:                                    4E1F 799A A4FF 2279
  * short id:                                             A4FF 2279
  Fingerprints can be used anywhere where an identifier is expected. For
  security reasons it is used instead of long and short identifier. Its only
  disadvantage is that it is less practical for manual human use.
  """
  keyFingerprint: String!
}

"""
Approval of data by third party with GnuPG signature that is created at some
point in time. It becomes invalid when the approved data changes, even if the
change is but a spelling-error correction in meta data like the description.
In that case, the third party needs to re-create its approval.

Steps to approve data:
1. An institution adds data to a database.
2. Some institution (may be the same) queries the data with a GraphQL query.
3. The latter institution reviews the data and, if correct, signs it with one
   of its GnuPG signing keys.
4. The institution adds its approval of the data to the database.

Storing the GraphQL query with the signature is necessary because it needs to be
known exactly which JSON data was signed.

Note that the query to be signed only includes paths that are part of the data
and not part of some associates, which are actually all paths in the present
GraphQL schema. However, the actual GraphQL schema of the database is in
general an extension of the present GraphQL schema and may have paths to some
associates like data format specifics of HTTP resources that it may fetch from
the "metabase" and provides for convenience. These specifics should not be
sigend as a change of, for example, the data format description would
invalidate the signature although the data itself did not change.
"""
type DataApproval implements Approval {
  """
  Creation timestamp
  """
  timestamp: DateTime!

  """
  Detached ASCII-armored GnuPG signature of the GraphQL query response.
  """
  signature: String!

  """
  Fingerprint of the GnuPG signing key used to compute the signature.
  """
  keyFingerprint: String!

  """
  GraphQL query whose response is signed. The query includes the argument
  `timestamp`, for example,
  `opticalData(opticalDataId: ..., timestamp: ...) { ... }`,
  as otherwise it is not reproducible. It does neither include other data
  approvals by third parties nor the response approval by the database.  All
  other fields and sub-fields of this GraphQL schema at the time given by
  `timestamp` are included. Despite these restrictions specifying the query
  explicitely is necessary because approvals must not become invalid when the
  GraphQL schema changes.
  """
  query: GraphQlQuery!

  """
  JSON serialized GraphQL response that is sigend.

  With the response put in the file `response.json`, the GnuPG signature put in
  the file `response.json.asc`, and the GnuPG public key of the approver added
  to the GnuPG key ring, the signature can be verified by running
  `gpg --verify response.json.asc response.json`.

  To compare the response `response.json` and another response `another.json`,
  run the command
  ```
  diff --side-by-side --suppress-common-lines \
    <(jq --sort-keys --monochrome-output . response.json) \
    <(jq --sort-keys --monochrome-output . another.json)
  ```
  in a
  [Bourne-again shell (Bash)](https://www.gnu.org/software/bash/),
  see
  [Faster and simpler with the command line: deep-comparing two 5GB JSON files 3X faster by ditching the code](https://genius.engineering/faster-and-simpler-with-the-command-line-deep-comparing-two-5gb-json-files-3x-faster-by-ditching-the-code/)
  and
  [Using jq or alternative command line tools to compare JSON files](https://stackoverflow.com/questions/31930041/using-jq-or-alternative-command-line-tools-to-compare-json-files/37175540#37175540).

  Comparing responses is necessary to verify that the data `another.json` you
  received in a query that includes this approval matches the approved data.
  Which is of course the case if all involved organizations are trustworthy.
  However, verified signatures and matching responses together prove data
  integrity (at least if private keys used to make the signatures in the first
  place are not compromised).
  """
  response: JsonGraphQlResponse!

  """
  Validity date and time range.
  """
  validity: OpenEndedDateTimeRange!

  """
  Approver identifier issued by the metabase. The approver's meta data can be
  obtained by sending the GraphQL query
  `stakeholder(stakeholderId: ..., timestamp: ...) { ... }`
  to the metabase.
  """
  approverId: Uuid!
}

"""
Approval of response by database with
[GnuPG](https://www.gnupg.org)
signature created on the fly.
"""
type ResponseApproval implements Approval {
  """
  Detached ASCII-armored GnuPG signature of the GraphQL query response.
  """
  signature: String!

  keyFingerprint: String!
}

"""
HTTP resource with meta information requestable through the protocol
[HTTP over TLS](https://tools.ietf.org/html/rfc2818)
with `GET` requests. The protocol is colloquially called Hypertext Transfer
Protocol Secure (HTTPS) and uses
[Transport Layer Security (TLS)](https://tools.ietf.org/html/rfc8446)
to secure
[Hypertext Transfer Protocol (HTTP)](https://tools.ietf.org/html/rfc7231)
connections over the internet.

If an HTTP `GET` request of the resource is
[successful](https://tools.ietf.org/html/rfc7231#section-6.3)
with
[HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6)
[200](https://tools.ietf.org/html/rfc7231#section-6.3.1),
the response message body is the resource's content. Otherwise, there is some
issue that can be identified and hopefully resolved by examining the status
code.

Note that the
[Internet Assigned Numbers Authority (IANA)](https://www.iana.org)
maintains the
[HTTP status code registry](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml).
See also
[HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
"""
type GetHttpsResource {
  """
  Description
  """
  description: String

  """
  Hash value of sucessful HTTP response message body with
  [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6)
  [200](https://tools.ietf.org/html/rfc7231#section-6.3.1)
  computed with
  Secure Hash Algorithm 256 (SHA-256)
  as described in the
  [United States's Federal Information Processing Standard 180-4 (FIPS 180-4)](https://csrc.nist.gov/publications/detail/fips/180/4/final)
  by the
  [National Institute of Standards and Technology (NIST)](https://www.nist.gov).
  See also
  [RFC 6234](https://tools.ietf.org/html/rfc6234).

  In Linux,
  1. install
     [Coreutils - GNU core utilities](https://www.gnu.org/software/coreutils/),
     to get the command-line tool
     [`sha256sum`](http://www.gnu.org/software/coreutils/sha256sum), and
  2. save the message body in a file, say `message.body`.

  Then, to compute the hash value,
  3. run the command `sha256sum message.body`, which prints the hash value to
     standard output.

  And, to check the hash value,
  4. run the command `echo '<HASH_VALUE>  message.body' | sha256sum --check`,
     where `<HASH_VALUE>` needs to be replaced by the hash value. Note that
     there are two spaces between `<HASH_VALUE>` and `message.body`.

  In Mac OS X, the command-line tool `shasum` comes pre-installed and can be
  used instead of `sha256sum` by adding the option `--algorithm 256` that is
  by literally replacing `sha256sum` in the above commands by
  `shasum --algorithm 256`.

  In Windows,
  1. install
     [PowerShell](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell)
  2. save the message body in a file, say `message.body`.
  3. open a PowerShell window, for example, by pressing `WIN+R`,
     typing in `powershell`, and pressing `<enter>`, and
  4. change directory to the folder with the saved files.

  Then, to compute the hash value,
  5. run the command
     `(Get-FileHash -Algorithm SHA256 .\message.body).Hash`,
     which prints the hash value. For details see the documentation
     [Get-FileHash](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-filehash).

  And, to check the hash value,
  6. save the message body's hash in a file, say `message.body.sha`,
  7. run the command
     `(Get-FileHash -Algorithm SHA256 .\message.body).Hash -eq (Get-Content .\message.body.sha).split(" ")[0].ToUpper()`,
     which prints `True` on success.

  In case [OpenSSL](https://www.openssl.org) is installed, to compute the hash
  value, you may also run `openssl dgst -sha256 message.body`.
  """
  hashValue: String!

  """
  Locator with scheme `https` meant to be used with protocol
  [HTTP over TLS](https://tools.ietf.org/html/rfc2818).
  """
  locator: Url!

  """
  Identifier of data format of successful HTTP response message body with
  [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6)
  [200](https://tools.ietf.org/html/rfc7231#section-6.3.1).
  The identifier is issued by the metabase. The format's meta data can be
  obtained by sending the GraphQL query
  `dataFormat(dataFormatId: ..., timestamp: ...) { ... }`
  to the metabase.

  The data format consists of a
  [media type](https://www.iana.org/assignments/media-types/media-types.xhtml)
  and additional information to unambiguously identify the specific format and
  to locate the format specification.

  In case of an
  [archive format](https://en.wikipedia.org/wiki/Archive_file),
  for each archived file (that is, each file in the archive), meta information
  like its data format is specified in `archivedFilesMetaInformation`. The file
  and directory names in the archive match the regular expression
  `^[0-9a-z-._]$` for reasons elaborated in `FileMetaInformation#path`. See
  also
  [List of archive formats](https://en.wikipedia.org/wiki/List_of_archive_formats).
  """
  formatId: Uuid!

  """
  Archived files meta information with relative paths from the archive root and
  data format specifications. In case the data format is not an archive, the
  list is empty. Otherwise, in case the data format is an, for our purposes,
  underspecified archive format like
  [7-Zip](https://www.7-zip.org)
  with an a priori unknown internal structure, for each archived file, there is
  exactly one list entry.

  Note that the
  [extensions of file names](https://en.wikipedia.org/wiki/Filename_extension)
  in the archive are not sufficient as data format because file extensions are
  not standardized and not sufficiently precise. For example, the extension
  `docx` is commonly used for documents with the media type
  [application/vnd.openxmlformats-officedocument.wordprocessingml.document](https://www.iana.org/assignments/media-types/application/vnd.openxmlformats-officedocument.wordprocessingml.document)
  but does not tell which exact version of the standard is meant.
  """
  archivedFilesMetaInformation: [FileMetaInformation!]!
}

type FileMetaInformation {
  """
  Relative file path, where
  * the string-serialized
    [POSIX-style path](https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap03.html#tag_03_266)
    is obtained by prepending the string `./` and joining all components with the
    forward slash `/`, see also,
    [IEEE/Open Group 1003.1-2017 - IEEE Standard for Information Technology--Portable Operating System Interface (POSIX(TR)) Base Specifications, Issue 7](https://standards.ieee.org/standard/1003_1-2017.html),
    and
  * the string-serialized
    [Windows-style path](https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
    is obtained by prepending the
    string `.\` and joining all components with the backward slash `\`, see also
    [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file).

  Each path component is a valid file or directory name in popular operating
  systems like various Linux distributions, Windows, and Mac OS X, and it is
  usable. Because of various idiosyncrasies of different file systems and
  command-line interpreters, each component matches the regular expression
  `^[a-z0-9-._]+$`. For some reasons see
  [Answer 1](https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os/358861#358861)
  and
  [Answer 2](https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os/748264#748264)
  to the dated question
  [What characters are safe in cross-platform file names for Linux, Windows and OS-X](https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os),
  and also
  [Best Practices for Filenames on the Web](https://www.surrealcms.com/blog/best-practices-for-filenames-on-the-web.html).
  """
  path: [String!]!

  """
  Identifier of the data format.  The identifier is issued by the metabase. The
  format's meta data can be obtained by sending the GraphQL query
  `dataFormat(dataFormatId: ..., timestamp: ...) { ... }`
  to the metabase.

  The data format consists of a
  [media type](https://www.iana.org/assignments/media-types/media-types.xhtml)
  and additional information to unambiguously identify the specific format and
  to locate the format specification.
  """
  formatId: Uuid!
}

"""
A root or non-root resource is the result of some measurement or simulation, or
of applying some conversion method to its parent resource.  Its child resources
are the results of applying conversion methods to it, the child resources of
its child resources are the results of applying conversion methods to the child
resources, and so forth. The applied conversion methods are specified in the
child resources.
"""
interface GetHttpsResourceVertex {
  """
  Resource
  """
  resource: GetHttpsResource!

  """
  Child resources obtained by applying conversion methods to the present
  resource.
  """
  children: [GetHttpsResourceNonRootVertex!]!
}

"""
A root resource is the direct result of some measurement or simulation.
"""
type GetHttpsResourceRoot implements GetHttpsResourceVertex {
  resource: GetHttpsResource!
  children: [GetHttpsResourceNonRootVertex!]!
}

"""
A non-root resource is the result of applying some conversion method to its
parent resource.
"""
type GetHttpsResourceNonRootVertex implements GetHttpsResourceVertex {
  resource: GetHttpsResource!
  children: [GetHttpsResourceNonRootVertex!]!

  """
  Conversion method applied to the parent resource to obtain the present
  resource.
  """
  appliedConversionMethod: AppliedMethodWithImplicitSources!
}
