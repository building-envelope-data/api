"""
Read-only GraphQL schema for the [metabase](https://www.buildingenvelopedata.org/graphql/) of the network of databases for [building envelope data](https://www.buildingenvelopedata.org). While the metabase stores meta information for example about components and institutions, the (child) databases store the data about building envelope components.

It follows best practices for
* [Global Object Identification](https://graphql.org/learn/global-object-identification/)
  as exemplified in
  [GraphQL Server Specification: Object Identification](https://relay.dev/docs/en/graphql-server-specification.html#object-identification)
  (see also [GraphQL Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)),
  and
* [Pagination](https://graphql.org/learn/pagination/),
  by adhering to the
  [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
  as exemplified in
  [GraphQL Server Specification: Connections](https://relay.dev/docs/en/graphql-server-specification.html#connections).

Global object identifiers as requird by the best practice are exposed by the
property `id` and universally unique identifiers as issued by the "metabase"
are exposed by the property `uuid`. In essence, `id` is the Base64-encoded
concatenation of `uuid` and the requested locale.

For interoperability with the (child) databases, implementations serve HTTP
requests as elaborated on
[Serving over HTTP](https://graphql.org/learn/serving-over-http/).

The
[Internet Engineering Task Force (IETF)](https://www.ietf.org)
is an Internet standards organization. It publishes standards in
[Request for Comments (RFC)](https://ietf.org/standards/rfcs/)
documents. They are
[searchable](https://www.rfc-editor.org/search/rfc_search.php)
and
[indexed](https://www.rfc-editor.org/rfc-index.html).
Examples are
[Hypertext Transfer Protocol (HTTP)](https://tools.ietf.org/html/rfc7231)
and
[Transport Layer Security (TLS)](https://tools.ietf.org/html/rfc8446).

The
[Internet Assigned Numbers Authority (IANA)](https://www.iana.org)
allocates and maintains unique codes and numbering systems that are used in
technical standards that drive the Internet like
[domain names](https://www.iana.org/domains),
[Internet Protocol addresses](https://www.iana.org/numbers), and
[registries](https://www.iana.org/protocols).
Examples of the last are
[HTTP status code registry](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)
and
[media type registry](https://www.iana.org/assignments/media-types/media-types.xhtml).

The
[International Organization for Standardization (ISO)](https://www.iso.org)
develops and publishes
[International Standards](https://www.iso.org/standards-catalogue/browse-by-ics.html).
Examples are
[ISO 8601 Date And Time Format](https://www.iso.org/iso-8601-date-and-time-format.html)
and
[ISO 3166 Country Codes](https://www.iso.org/iso-3166-country-codes.html).

The library
[graphql-scalars](https://github.com/Urigo/graphql-scalars)
introduces custom scalar types for creating precise type-safe GraphQL schemas.
We took some inspiration from
[GitHub GraphQL API](https://docs.github.com/en/graphql).
"""
scalar Schema

"""
[RFC 4122](https://tools.ietf.org/html/rfc4122)
compliant
[non-nil](https://tools.ietf.org/html/rfc4122#section-4.1.7)
[Universally Unique Identifier (UUID)](https://tools.ietf.org/html/rfc4122#section-4.1)
string represented as 32 hexadecimal digits in five groups separated by hyphens
in the form `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`, like
`"936da01f-9abd-4d9d-80c7-02af85c822a8"`. Such identifiers are not equal to
`"00000000-0000-0000-0000-000000000000"` and match the regular expression
`^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$`.
"""
scalar Uuid

"""
[GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)
compliant
[Cursor](https://relay.dev/graphql/connections.htm#sec-Cursor)
string.
"""
scalar Cursor

schema {
  query: Query
  mutation: Mutation
}

interface Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  description: String
  name: String
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface Reference {
  abstract: String
  section: String
  title: String
}

interface Stakeholder {
  name: String!
}

type AddInstitutionRepresentativeError {
  code: AddInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type AddInstitutionRepresentativePayload {
  errors: [AddInstitutionRepresentativeError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type AddUserRoleError {
  code: AddUserRoleErrorCode!
  message: String!
  path: [String!]!
}

type AddUserRolePayload {
  errors: [AddUserRoleError!]
  user: User
}

type AppliedMethod {
  methodId: Uuid!
}

type CalorimetricData implements Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  description: String
  gValues: [Float!]!
  name: String
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  uValues: [Float!]!
}

type CalorimetricDataConnection {
  edges: [CalorimetricDataEdge!]!
  nodes: [CalorimetricData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type CalorimetricDataEdge {
  cursor: String!
  node: CalorimetricData!
}

type ChangeInstitutionRepresentativeRoleError {
  code: ChangeInstitutionRepresentativeRoleErrorCode!
  message: String!
  path: [String!]!
}

type ChangeInstitutionRepresentativeRolePayload {
  errors: [ChangeInstitutionRepresentativeRoleError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type ChangeUserEmailError {
  code: ChangeUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserEmailPayload {
  errors: [ChangeUserEmailError!]
  user: User
}

type ChangeUserPasswordError {
  code: ChangeUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserPasswordPayload {
  errors: [ChangeUserPasswordError!]
  user: User
}

type Component implements Node {
  abbreviation: String
  availability: OpenEndedDateTimeRange
  categories: [ComponentCategory!]!
  description: String!
  id: ID!
  manufacturers(pending: Boolean! = false): ComponentManufacturerConnection!
  name: String!
  uuid: Uuid!
}

"A connection to a list of items."
type ComponentConnection {
  "A list of edges."
  edges: [ComponentEdge!]
  "A flattened list of the nodes."
  nodes: [Component!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type ComponentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Component!
}

type ComponentManufacturerConnection {
  edges: [ComponentManufacturerEdge!]!
  pageInfo: PageInfo!
}

type ComponentManufacturerEdge {
  node: Institution!
}

type ConfirmComponentManufacturerError {
  code: ConfirmComponentManufacturerErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmComponentManufacturerPayload {
  componentManufacturerEdge: ComponentManufacturerEdge
  errors: [ConfirmComponentManufacturerError!]
  manufacturedComponentEdge: InstitutionManufacturedComponentEdge
}

type ConfirmInstitutionMethodDeveloperError {
  code: ConfirmInstitutionMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmInstitutionMethodDeveloperPayload {
  developedMethodEdge: InstitutionDevelopedMethodEdge
  errors: [ConfirmInstitutionMethodDeveloperError!]
  methodDeveloperEdge: InstitutionMethodDeveloperEdge
}

type ConfirmInstitutionRepresentativeError {
  code: ConfirmInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmInstitutionRepresentativePayload {
  errors: [ConfirmInstitutionRepresentativeError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type ConfirmUserEmailChangeError {
  code: ConfirmUserEmailChangeErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailChangePayload {
  errors: [ConfirmUserEmailChangeError!]
  user: User
}

type ConfirmUserEmailError {
  code: ConfirmUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailPayload {
  errors: [ConfirmUserEmailError!]
  user: User
}

type ConfirmUserMethodDeveloperError {
  code: ConfirmUserMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserMethodDeveloperPayload {
  developedMethodEdge: UserDevelopedMethodEdge
  errors: [ConfirmUserMethodDeveloperError!]
  methodDeveloperEdge: UserMethodDeveloperEdge
}

type CreateComponentError {
  code: CreateComponentErrorCode!
  message: String!
  path: [String!]!
}

type CreateComponentPayload {
  component: Component
  errors: [CreateComponentError!]
}

type CreateDataFormatError {
  code: CreateDataFormatErrorCode!
  message: String!
  path: [String!]!
}

type CreateDataFormatPayload {
  dataFormat: DataFormat
  errors: [CreateDataFormatError!]
}

type CreateDatabaseError {
  code: CreateDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type CreateDatabasePayload {
  database: Database
  errors: [CreateDatabaseError!]
}

type CreateInstitutionError {
  code: CreateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type CreateInstitutionPayload {
  errors: [CreateInstitutionError!]
  institution: Institution
}

type CreateMethodError {
  code: CreateMethodErrorCode!
  message: String!
  path: [String!]!
}

type CreateMethodPayload {
  errors: [CreateMethodError!]
  method: Method
}

type DataApproval {
  approverId: Uuid!
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

type DataConnection {
  edges: [DataEdge!]!
  nodes: [Data!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type DataEdge {
  cursor: String!
  node: Data!
}

type DataFormat implements Node {
  description: String!
  extension: String
  id: ID!
  manager: DataFormatManagerEdge!
  mediaType: String!
  name: String!
  reference: Reference
  schemaLocator: Url
  uuid: Uuid!
}

"A connection to a list of items."
type DataFormatConnection {
  "A list of edges."
  edges: [DataFormatEdge!]
  "A flattened list of the nodes."
  nodes: [DataFormat!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type DataFormatEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DataFormat!
}

type DataFormatManagerEdge {
  node: Institution!
}

type Database implements Node {
  allCalorimetricData(
    after: String
    before: String
    first: NonNegativeInt
    last: NonNegativeInt
    locale: String
    timestamp: DateTime
    where: CalorimetricDataPropositionInput
  ): CalorimetricDataConnection
  allData(
    after: String
    before: String
    first: NonNegativeInt
    last: NonNegativeInt
    locale: String
    timestamp: DateTime
    where: DataPropositionInput
  ): DataConnection
  allHygrothermalData(
    after: String
    before: String
    first: NonNegativeInt
    last: NonNegativeInt
    locale: String
    timestamp: DateTime
    where: HygrothermalDataPropositionInput
  ): HygrothermalDataConnection
  allOpticalData(
    after: String
    before: String
    first: NonNegativeInt
    last: NonNegativeInt
    locale: String
    timestamp: DateTime
    where: OpticalDataPropositionInput
  ): OpticalDataConnection
  allPhotovoltaicData(
    after: String
    before: String
    first: NonNegativeInt
    last: NonNegativeInt
    locale: String
    timestamp: DateTime
    where: PhotovoltaicDataPropositionInput
  ): PhotovoltaicDataConnection
  calorimetricData(
    id: Uuid!
    locale: String
    timestamp: DateTime
  ): CalorimetricData
  data(id: Uuid!, locale: String, timestamp: DateTime): Data
  description: String!
  hasCalorimetricData(
    locale: String
    timestamp: DateTime
    where: CalorimetricDataPropositionInput
  ): Boolean
  hasData(
    locale: String
    timestamp: DateTime
    where: DataPropositionInput
  ): Boolean
  hasHygrothermalData(
    locale: String
    timestamp: DateTime
    where: HygrothermalDataPropositionInput
  ): Boolean
  hasOpticalData(
    locale: String
    timestamp: DateTime
    where: OpticalDataPropositionInput
  ): Boolean
  hasPhotovoltaicData(
    locale: String
    timestamp: DateTime
    where: PhotovoltaicDataPropositionInput
  ): Boolean
  hygrothermalData(
    id: Uuid!
    locale: String
    timestamp: DateTime
  ): HygrothermalData
  id: ID!
  locator: Url!
  name: String!
  operator: DatabaseOperatorEdge!
  opticalData(id: Uuid!, locale: String, timestamp: DateTime): OpticalData
  photovoltaicData(
    id: Uuid!
    locale: String
    timestamp: DateTime
  ): PhotovoltaicData
  uuid: Uuid!
}

"A connection to a list of items."
type DatabaseConnection {
  "A list of edges."
  edges: [DatabaseEdge!]
  "A flattened list of the nodes."
  nodes: [Database!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

"An edge in a connection."
type DatabaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Database!
}

type DatabaseOperatorEdge {
  node: Institution!
}

type DeleteInstitutionError {
  code: DeleteInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type DeleteInstitutionPayload {
  errors: [DeleteInstitutionError!]
}

type DeletePersonalUserDataError {
  code: DeletePersonalUserDataErrorCode!
  message: String!
  path: [String!]!
}

type DeletePersonalUserDataPayload {
  errors: [DeletePersonalUserDataError!]
  user: User
}

type DeleteUserError {
  code: DeleteUserErrorCode!
  message: String!
  path: [String!]!
}

type DeleteUserPayload {
  errors: [DeleteUserError!]
  user: User
}

type DisableUserTwoFactorAuthenticationError {
  code: DisableUserTwoFactorAuthenticationErrorCode!
  message: String!
  path: [String!]!
}

type DisableUserTwoFactorAuthenticationPayload {
  errors: [DisableUserTwoFactorAuthenticationError!]
  user: User
}

type EnableUserTwoFactorAuthenticatorError {
  code: EnableUserTwoFactorAuthenticatorErrorCode!
  message: String!
  path: [String!]!
}

type EnableUserTwoFactorAuthenticatorPayload {
  authenticatorUri: String
  errors: [EnableUserTwoFactorAuthenticatorError!]
  sharedKey: String
  twoFactorRecoveryCodes: [String!]
  user: User
}

type ForgetUserTwoFactorAuthenticationClientError {
  code: ForgetUserTwoFactorAuthenticationClientErrorCode!
  message: String!
  path: [String!]!
}

type ForgetUserTwoFactorAuthenticationClientPayload {
  errors: [ForgetUserTwoFactorAuthenticationClientError!]
  user: User
}

type GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriError {
  code: GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriErrorCode!
  message: String!
  path: [String!]!
}

type GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriPayload {
  authenticatorUri: String
  errors: [GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriError!]
  sharedKey: String
  user: User
}

type GenerateUserTwoFactorRecoveryCodesError {
  code: GenerateUserTwoFactorRecoveryCodesErrorCode!
  message: String!
  path: [String!]!
}

type GenerateUserTwoFactorRecoveryCodesPayload {
  errors: [GenerateUserTwoFactorRecoveryCodesError!]
  twoFactorRecoveryCodes: [String!]
  user: User
}

type GetHttpsResource {
  description: String!
  formatId: Uuid!
  hashValue: String!
  locator: Url!
}

type GetHttpsResourceTree {
  root: GetHttpsResourceTreeRoot!
}

type GetHttpsResourceTreeNonRootVertex {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod!
  parentId: String!
  value: GetHttpsResource!
  vertexId: String!
}

type GetHttpsResourceTreeRoot {
  value: GetHttpsResource!
}

type HygrothermalData implements Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  description: String
  name: String
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
}

type HygrothermalDataConnection {
  edges: [HygrothermalDataEdge!]!
  nodes: [HygrothermalData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type HygrothermalDataEdge {
  cursor: String!
  node: HygrothermalData!
}

type Institution implements Node & Stakeholder {
  abbreviation: String
  description: String!
  developedMethods(
    pending: Boolean! = false
  ): InstitutionDevelopedMethodConnection!
  id: ID!
  managedDataFormats: InstitutionManagedDataFormatConnection!
  managedInstitutions: InstitutionManagedInstitutionConnection!
  managedMethods: InstitutionManagedMethodConnection!
  manager: InstitutionManagerEdge
  manufacturedComponents(
    pending: Boolean! = false
  ): InstitutionManufacturedComponentConnection!
  name: String!
  operatedDatabases: InstitutionOperatedDatabaseConnection!
  publicKey: String
  representatives(
    pending: Boolean! = false
  ): InstitutionRepresentativeConnection!
  state: InstitutionState!
  uuid: Uuid!
  websiteLocator: Url
}

"A connection to a list of items."
type InstitutionConnection {
  "A list of edges."
  edges: [InstitutionEdge!]
  "A flattened list of the nodes."
  nodes: [Institution]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type InstitutionDevelopedMethodConnection {
  canCurrentUserConfirmEdge: Boolean!
  edges: [InstitutionDevelopedMethodEdge!]!
  pageInfo: PageInfo!
}

type InstitutionDevelopedMethodEdge {
  node: Method!
}

"An edge in a connection."
type InstitutionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Institution
}

type InstitutionManagedDataFormatConnection {
  canCurrentUserAddEdge: Boolean!
  edges: [InstitutionManagedDataFormatEdge!]!
  pageInfo: PageInfo!
}

type InstitutionManagedDataFormatEdge {
  node: DataFormat!
}

type InstitutionManagedInstitutionConnection {
  canCurrentUserAddEdge: Boolean!
  edges: [InstitutionManagedInstitutionEdge!]!
  pageInfo: PageInfo!
}

type InstitutionManagedInstitutionEdge {
  node: Institution!
}

type InstitutionManagedMethodConnection {
  canCurrentUserAddEdge: Boolean!
  edges: [InstitutionManagedMethodEdge!]!
  pageInfo: PageInfo!
}

type InstitutionManagedMethodEdge {
  node: Method!
}

type InstitutionManagerEdge {
  node: Institution!
}

type InstitutionManufacturedComponentConnection {
  canCurrentUserAddEdge: Boolean!
  canCurrentUserConfirmEdge: Boolean!
  edges: [InstitutionManufacturedComponentEdge!]!
  pageInfo: PageInfo!
}

type InstitutionManufacturedComponentEdge {
  node: Component!
}

type InstitutionMethodDeveloperEdge {
  node: Institution!
}

type InstitutionOperatedDatabaseConnection {
  canCurrentUserAddEdge: Boolean!
  edges: [InstitutionOperatedDatabaseEdge!]!
  pageInfo: PageInfo!
}

type InstitutionOperatedDatabaseEdge {
  node: Database!
}

type InstitutionRepresentativeConnection {
  canCurrentUserAddEdge: Boolean!
  edges: [InstitutionRepresentativeEdge!]!
  pageInfo: PageInfo!
}

type InstitutionRepresentativeEdge {
  node: User!
  role: InstitutionRepresentativeRole!
}

type LoginUserError {
  code: LoginUserErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserPayload {
  errors: [LoginUserError!]
  requiresTwoFactor: Boolean
  user: User
}

type LoginUserWithRecoveryCodeError {
  code: LoginUserWithRecoveryCodeErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserWithRecoveryCodePayload {
  errors: [LoginUserWithRecoveryCodeError!]
  user: User
}

type LoginUserWithTwoFactorCodeError {
  code: LoginUserWithTwoFactorCodeErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserWithTwoFactorCodePayload {
  errors: [LoginUserWithTwoFactorCodeError!]
  user: User
}

type LogoutUserError {
  code: LogoutUserErrorCode!
  message: String!
  path: [String!]!
}

type LogoutUserPayload {
  errors: [LogoutUserError!]
  user: User
}

type Method implements Node {
  availability: OpenEndedDateTimeRange
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  developers(pending: Boolean! = false): MethodDeveloperConnection!
  id: ID!
  manager: MethodManagerEdge!
  name: String!
  reference: Reference
  uuid: Uuid!
  validity: OpenEndedDateTimeRange
}

"A connection to a list of items."
type MethodConnection {
  "A list of edges."
  edges: [MethodEdge!]
  "A flattened list of the nodes."
  nodes: [Method!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type MethodDeveloperConnection {
  edges: [MethodDeveloperEdge!]!
  pageInfo: PageInfo!
}

type MethodDeveloperEdge {
  node: Stakeholder!
}

"An edge in a connection."
type MethodEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Method!
}

type MethodManagerEdge {
  node: Institution!
}

type Mutation {
  addInstitutionRepresentative(
    input: AddInstitutionRepresentativeInput!
  ): AddInstitutionRepresentativePayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  addUserRole(input: AddUserRoleInput!): AddUserRolePayload!
  changeInstitutionRepresentativeRole(
    input: ChangeInstitutionRepresentativeRoleInput!
  ): ChangeInstitutionRepresentativeRolePayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  changeUserPassword(
    input: ChangeUserPasswordInput!
  ): ChangeUserPasswordPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  confirmComponentManufacturer(
    input: ConfirmComponentManufacturerInput!
  ): ConfirmComponentManufacturerPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  confirmInstitutionMethodDeveloper(
    input: ConfirmInstitutionMethodDeveloperInput!
  ): ConfirmInstitutionMethodDeveloperPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  confirmInstitutionRepresentative(
    input: ConfirmInstitutionRepresentativeInput!
  ): ConfirmInstitutionRepresentativePayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  confirmUserEmail(input: ConfirmUserEmailInput!): ConfirmUserEmailPayload!
  confirmUserEmailChange(
    input: ConfirmUserEmailChangeInput!
  ): ConfirmUserEmailChangePayload!
  confirmUserMethodDeveloper(
    input: ConfirmUserMethodDeveloperInput!
  ): ConfirmUserMethodDeveloperPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createComponent(input: CreateComponentInput!): CreateComponentPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createDatabase(input: CreateDatabaseInput!): CreateDatabasePayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createDataFormat(input: CreateDataFormatInput!): CreateDataFormatPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createInstitution(input: CreateInstitutionInput!): CreateInstitutionPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  createMethod(input: CreateMethodInput!): CreateMethodPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  deleteInstitution(input: DeleteInstitutionInput!): DeleteInstitutionPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  deletePersonalUserData(
    input: DeletePersonalUserDataInput!
  ): DeletePersonalUserDataPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  deleteUser(input: DeleteUserInput!): DeleteUserPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  disableUserTwoFactorAuthentication: DisableUserTwoFactorAuthenticationPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  enableUserTwoFactorAuthenticator(
    input: EnableUserTwoFactorAuthenticatorInput!
  ): EnableUserTwoFactorAuthenticatorPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  forgetUserTwoFactorAuthenticationClient: ForgetUserTwoFactorAuthenticationClientPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  generateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUri: GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  generateUserTwoFactorRecoveryCodes: GenerateUserTwoFactorRecoveryCodesPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  loginUser(input: LoginUserInput!): LoginUserPayload!
  loginUserWithRecoveryCode(
    input: LoginUserWithRecoveryCodeInput!
  ): LoginUserWithRecoveryCodePayload!
  loginUserWithTwoFactorCode(
    input: LoginUserWithTwoFactorCodeInput!
  ): LoginUserWithTwoFactorCodePayload!
  logoutUser: LogoutUserPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  registerUser(input: RegisterUserInput!): RegisterUserPayload!
  removeInstitutionRepresentative(
    input: RemoveInstitutionRepresentativeInput!
  ): RemoveInstitutionRepresentativePayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  removeUserRole(input: RemoveUserRoleInput!): RemoveUserRolePayload!
  requestUserPasswordReset(
    input: RequestUserPasswordResetInput!
  ): RequestUserPasswordResetPayload!
  resendUserEmailConfirmation(
    input: ResendUserEmailConfirmationInput!
  ): ResendUserEmailConfirmationPayload!
  resendUserEmailVerification: ResendUserEmailVerificationPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  resetUserPassword(input: ResetUserPasswordInput!): ResetUserPasswordPayload!
  resetUserTwoFactorAuthenticator: ResetUserTwoFactorAuthenticatorPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  setUserPassword(input: SetUserPasswordInput!): SetUserPasswordPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  setUserPhoneNumber(
    input: SetUserPhoneNumberInput!
  ): SetUserPhoneNumberPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "ManageUser")
  updateInstitution(input: UpdateInstitutionInput!): UpdateInstitutionPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
  verifyInstitution(input: VerifyInstitutionInput!): VerifyInstitutionPayload!
    @authorize(apply: BEFORE_RESOLVER, policy: "Write")
}

type NamedMethodArgument {
  name: String!
}

type Numeration {
  mainNumber: String!
  prefix: String
  suffix: String
}

type OpenEndedDateTimeRange {
  from: DateTime
  to: DateTime
}

type OpenIdConnectApplication {
  authorizations: [OpenIdConnectAuthorization!]!
  clientId: String
  clientSecret: String
  concurrencyToken: String
  consentType: String
  displayName: String
  displayNames: String
  id: String
  permissions: String
  postLogoutRedirectUris: String
  properties: String
  redirectUris: String
  requirements: String
  tokens: [OpenIdConnectToken!]!
  type: String
}

type OpenIdConnectAuthorization {
  application: OpenIdConnectApplication
  concurrencyToken: String
  creationDate: DateTime
  id: String
  properties: String
  scopes: String
  status: String
  subject: String
  tokens: [OpenIdConnectToken!]!
  type: String
}

type OpenIdConnectScope {
  concurrencyToken: String
  description: String
  descriptions: String
  displayName: String
  displayNames: String
  id: String
  name: String
  properties: String
  resources: String
}

type OpenIdConnectToken {
  application: OpenIdConnectApplication
  authorization: OpenIdConnectAuthorization
  concurrencyToken: String
  creationDate: DateTime
  expirationDate: DateTime
  id: String
  payload: String
  properties: String
  redemptionDate: DateTime
  referenceId: String
  status: String
  subject: String
  type: String
}

type OpticalData implements Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  description: String
  name: String
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
}

type OpticalDataConnection {
  edges: [OpticalDataEdge!]!
  nodes: [OpticalData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type OpticalDataEdge {
  cursor: String!
  node: OpticalData!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PhotovoltaicData implements Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  description: String
  name: String
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
}

type PhotovoltaicDataConnection {
  edges: [PhotovoltaicDataEdge!]!
  nodes: [PhotovoltaicData!]!
  pageInfo: PageInfo!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type PhotovoltaicDataEdge {
  cursor: String!
  node: PhotovoltaicData!
}

type Publication implements Reference {
  abstract: String
  "A free and open-access archive for publications is offered by arXiv.org. The arXiv identifier can be used to define a publication."
  arXiv: String
  authors: [String!]
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: String
  "Referenced section"
  section: String
  title: String
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: String
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: Url
}

type Query {
  component(uuid: Uuid!): Component
  components(
    after: String
    before: String
    first: Int
    last: Int
    order: [ComponentSortInput!]
    where: ComponentFilterInput
  ): ComponentConnection
  currentUser: User
  database(uuid: Uuid!): Database
  databases(
    after: String
    before: String
    first: Int
    last: Int
    order: [DatabaseSortInput!]
    where: DatabaseFilterInput
  ): DatabaseConnection
  dataFormat(uuid: Uuid!): DataFormat
  dataFormats(
    after: String
    before: String
    first: Int
    last: Int
    order: [DataFormatSortInput!]
    where: DataFormatFilterInput
  ): DataFormatConnection
  institution(uuid: Uuid!): Institution
  institutions(
    after: String
    before: String
    first: Int
    last: Int
    order: [InstitutionSortInput!]
    where: InstitutionFilterInput
  ): InstitutionConnection
  method(uuid: Uuid!): Method
  methods(
    after: String
    before: String
    first: Int
    last: Int
    order: [MethodSortInput!]
    where: MethodFilterInput
  ): MethodConnection
  node(id: ID!): Node
  openIdConnectApplications: [OpenIdConnectApplication!]!
  openIdConnectAuthorizations: [OpenIdConnectAuthorization!]!
  openIdConnectScopes: [OpenIdConnectScope!]!
  openIdConnectTokens: [OpenIdConnectToken!]!
  user(uuid: Uuid!): User
  users(
    after: String
    before: String
    first: Int
    last: Int
    order: [UserSortInput!]
  ): UserConnection
}

type RegisterUserError {
  code: RegisterUserErrorCode!
  message: String!
  path: [String!]!
}

type RegisterUserPayload {
  errors: [RegisterUserError!]
  user: User
}

type RemoveInstitutionRepresentativeError {
  code: RemoveInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type RemoveInstitutionRepresentativePayload {
  errors: [RemoveInstitutionRepresentativeError!]
  institution: Institution!
  user: User!
}

type RemoveUserRoleError {
  code: RemoveUserRoleErrorCode!
  message: String!
  path: [String!]!
}

type RemoveUserRolePayload {
  errors: [RemoveUserRoleError!]
  user: User
}

type RequestUserPasswordResetError {
  code: RequestUserPasswordResetErrorCode!
  message: String!
  path: [String!]!
}

type RequestUserPasswordResetPayload {
  errors: [RequestUserPasswordResetError!]
}

type ResendUserEmailConfirmationError {
  code: ResendUserEmailConfirmationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailConfirmationPayload {
  errors: [ResendUserEmailConfirmationError!]
}

type ResendUserEmailVerificationError {
  code: ResendUserEmailVerificationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailVerificationPayload {
  errors: [ResendUserEmailVerificationError!]
  user: User
}

type ResetUserPasswordError {
  code: ResetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ResetUserPasswordPayload {
  errors: [ResetUserPasswordError!]
}

type ResetUserTwoFactorAuthenticatorError {
  code: ResetUserTwoFactorAuthenticatorErrorCode!
  message: String!
  path: [String!]!
}

type ResetUserTwoFactorAuthenticatorPayload {
  errors: [ResetUserTwoFactorAuthenticatorError!]
  user: User
}

type ResponseApproval {
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

type SetUserPasswordError {
  code: SetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPasswordPayload {
  errors: [SetUserPasswordError!]
  user: User
}

type SetUserPhoneNumberError {
  code: SetUserPhoneNumberErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPhoneNumberPayload {
  errors: [SetUserPhoneNumberError!]
  user: User
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
type Standard implements Reference {
  abstract: String
  locator: Url
  numeration: Numeration!
  "The section of the standard to which the reference refers to."
  section: String
  standardizers: [Standardizer!]!
  title: String!
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: Int
}

type ToTreeVertexAppliedConversionMethod {
  arguments: [NamedMethodArgument!]!
  methodId: Uuid!
  sourceName: String!
}

type TwoFactorAuthentication {
  hasAuthenticator: Boolean!
  isEnabled: Boolean!
  isMachineRemembered: Boolean!
  recoveryCodesLeftCount: Int!
}

type UpdateInstitutionError {
  code: UpdateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type UpdateInstitutionPayload {
  errors: [UpdateInstitutionError!]
  institution: Institution
}

type User implements Node & Stakeholder {
  canCurrentUserDeleteUser: Boolean!
  developedMethods(pending: Boolean! = false): UserDevelopedMethodConnection!
  email: String
  hasPassword: Boolean
  id: ID!
  isEmailConfirmed: Boolean
  isPhoneNumberConfirmed: Boolean
  "Full name"
  name: String!
  phoneNumber: String
  representedInstitutions(
    pending: Boolean! = false
  ): UserRepresentedInstitutionConnection!
  roles: [UserRole!]
  rolesCurrentUserCanAdd: [UserRole!]
  rolesCurrentUserCanRemove: [UserRole!]
  twoFactorAuthentication: TwoFactorAuthentication
  uuid: Uuid!
  websiteLocator: Url
}

"A connection to a list of items."
type UserConnection {
  "A list of edges."
  edges: [UserEdge!]
  "A flattened list of the nodes."
  nodes: [User!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserDevelopedMethodConnection {
  canCurrentUserConfirmEdge: Boolean!
  edges: [UserDevelopedMethodEdge!]!
  pageInfo: PageInfo!
}

type UserDevelopedMethodEdge {
  node: Method!
}

"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User!
}

type UserMethodDeveloperEdge {
  node: User!
}

type UserRepresentedInstitutionConnection {
  canCurrentUserConfirmEdge: Boolean!
  edges: [UserRepresentedInstitutionEdge!]!
  pageInfo: PageInfo!
}

type UserRepresentedInstitutionEdge {
  node: Institution!
  role: InstitutionRepresentativeRole!
}

type VerifyInstitutionError {
  code: VerifyInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type VerifyInstitutionPayload {
  errors: [VerifyInstitutionError!]
  institution: Institution
}

input AddInstitutionRepresentativeInput {
  institutionId: Uuid!
  role: InstitutionRepresentativeRole!
  userId: Uuid!
}

input AddUserRoleInput {
  role: UserRole!
  userId: Uuid!
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input CalorimetricDataPropositionInput {
  and: [CalorimetricDataPropositionInput!]
  componentId: UuidPropositionInput
  gValue: FloatPropositionInput
  not: CalorimetricDataPropositionInput
  or: [CalorimetricDataPropositionInput!]
  uValue: FloatPropositionInput
}

input ChangeInstitutionRepresentativeRoleInput {
  institutionId: Uuid!
  newRole: InstitutionRepresentativeRole!
  userId: Uuid!
}

input ChangeUserEmailInput {
  newEmail: String!
}

input ChangeUserPasswordInput {
  currentPassword: String!
  newPassword: String!
  newPasswordConfirmation: String!
}

input ClosedIntervalInput {
  lowerBound: Float!
  upperBound: Float!
}

input ComparableGuidOperationFilterInput {
  eq: Uuid
  gt: Uuid
  gte: Uuid
  in: [Uuid!]
  lt: Uuid
  lte: Uuid
  neq: Uuid
  ngt: Uuid
  ngte: Uuid
  nin: [Uuid!]
  nlt: Uuid
  nlte: Uuid
}

input ComparableInt32OperationFilterInput {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  neq: Int
  ngt: Int
  ngte: Int
  nin: [Int!]
  nlt: Int
  nlte: Int
}

input ComponentCategoryOperationFilterInput {
  eq: ComponentCategory
  in: [ComponentCategory!]
  neq: ComponentCategory
  nin: [ComponentCategory!]
}

input ComponentFilterInput {
  abbreviation: StringOperationFilterInput
  and: [ComponentFilterInput!]
  categories: ListComponentCategoryOperationFilterInput
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [ComponentFilterInput!]
}

input ComponentSortInput {
  abbreviation: SortEnumType
  availability: SortEnumType
  description: SortEnumType
  id: SortEnumType
  name: SortEnumType
  xmin: SortEnumType
}

input ConfirmComponentManufacturerInput {
  componentId: Uuid!
  institutionId: Uuid!
}

input ConfirmInstitutionMethodDeveloperInput {
  institutionId: Uuid!
  methodId: Uuid!
}

input ConfirmInstitutionRepresentativeInput {
  institutionId: Uuid!
  userId: Uuid!
}

input ConfirmUserEmailChangeInput {
  confirmationCode: String!
  currentEmail: String!
  newEmail: String!
}

input ConfirmUserEmailInput {
  confirmationCode: String!
  email: String!
}

input ConfirmUserMethodDeveloperInput {
  methodId: Uuid!
  userId: Uuid!
}

input CreateComponentInput {
  abbreviation: String
  availability: OpenEndedDateTimeRangeInput
  categories: [ComponentCategory!]!
  description: String!
  manufacturerId: Uuid!
  name: String!
}

input CreateDataFormatInput {
  description: String!
  extension: String
  managerId: Uuid!
  mediaType: String!
  name: String!
  publication: CreatePublicationInput
  schemaLocator: Url
  standard: CreateStandardInput
}

input CreateDatabaseInput {
  description: String!
  locator: Url!
  name: String!
  operatorId: Uuid!
}

input CreateInstitutionInput {
  abbreviation: String
  description: String!
  managerId: Uuid
  name: String!
  ownerIds: [Uuid!]!
  publicKey: String
  websiteLocator: Url
}

input CreateMethodInput {
  availability: OpenEndedDateTimeRangeInput
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  institutionDeveloperIds: [Uuid!]!
  managerId: Uuid!
  name: String!
  publication: CreatePublicationInput
  standard: CreateStandardInput
  userDeveloperIds: [Uuid!]!
  validity: OpenEndedDateTimeRangeInput
}

input CreateNumerationInput {
  mainNumber: String!
  prefix: String
  suffix: String
}

input CreatePublicationInput {
  abstract: String
  arXiv: String
  authors: [String!]
  doi: String
  section: String
  title: String
  urn: String
  webAddress: Url
}

input CreateStandardInput {
  abstract: String
  locator: Url
  numeration: CreateNumerationInput!
  section: String
  standardizers: [Standardizer!]!
  title: String
  year: Int
}

input DataFormatFilterInput {
  and: [DataFormatFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  mediaType: StringOperationFilterInput
  name: StringOperationFilterInput
  or: [DataFormatFilterInput!]
}

input DataFormatSortInput {
  description: SortEnumType
  extension: SortEnumType
  id: SortEnumType
  manager: InstitutionSortInput
  managerId: SortEnumType
  mediaType: SortEnumType
  name: SortEnumType
  publication: PublicationSortInput
  reference: IReferenceSortInput
  schemaLocator: UriSortInput
  standard: StandardSortInput
  xmin: SortEnumType
}

input DataPropositionInput {
  and: [DataPropositionInput!]
  componentId: UuidPropositionInput
  gValue: FloatPropositionInput
  nearnormalHemisphericalVisibleTransmittance: FloatPropositionInput
  not: DataPropositionInput
  or: [DataPropositionInput!]
  uValue: FloatPropositionInput
}

input DatabaseFilterInput {
  and: [DatabaseFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  locator: UriFilterInput
  name: StringOperationFilterInput
  or: [DatabaseFilterInput!]
}

input DatabaseSortInput {
  description: SortEnumType
  id: SortEnumType
  locator: UriSortInput
  name: SortEnumType
  operator: InstitutionSortInput
  operatorId: SortEnumType
  xmin: SortEnumType
}

input DeleteInstitutionInput {
  institutionId: Uuid!
}

input DeletePersonalUserDataInput {
  password: String
}

input DeleteUserInput {
  userId: Uuid!
}

input EnableUserTwoFactorAuthenticatorInput {
  verificationCode: String!
}

input FloatPropositionInput {
  equalTo: Float
  greaterThanOrEqualTo: Float
  inClosedInterval: ClosedIntervalInput
  lessThanOrEqualTo: Float
}

input HygrothermalDataPropositionInput {
  and: [HygrothermalDataPropositionInput!]
  componentId: UuidPropositionInput
  not: HygrothermalDataPropositionInput
  or: [HygrothermalDataPropositionInput!]
}

input IReferenceSortInput {
  abstract: SortEnumType
  section: SortEnumType
  title: SortEnumType
}

input InstitutionFilterInput {
  abbreviation: StringOperationFilterInput
  and: [InstitutionFilterInput!]
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [InstitutionFilterInput!]
  state: InstitutionStateOperationFilterInput
  websiteLocator: UriFilterInput
}

input InstitutionSortInput {
  abbreviation: SortEnumType
  description: SortEnumType
  id: SortEnumType
  manager: InstitutionSortInput
  managerId: SortEnumType
  name: SortEnumType
  publicKey: SortEnumType
  state: SortEnumType
  websiteLocator: UriSortInput
  xmin: SortEnumType
}

input InstitutionStateOperationFilterInput {
  eq: InstitutionState
  in: [InstitutionState!]
  neq: InstitutionState
  nin: [InstitutionState!]
}

input ListComponentCategoryOperationFilterInput {
  all: ComponentCategoryOperationFilterInput
  any: Boolean
  none: ComponentCategoryOperationFilterInput
  some: ComponentCategoryOperationFilterInput
}

input ListMethodCategoryOperationFilterInput {
  all: MethodCategoryOperationFilterInput
  any: Boolean
  none: MethodCategoryOperationFilterInput
  some: MethodCategoryOperationFilterInput
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  any: Boolean
  none: StringOperationFilterInput
  some: StringOperationFilterInput
}

input LoginUserInput {
  email: String!
  password: String!
  rememberMe: Boolean!
}

input LoginUserWithRecoveryCodeInput {
  recoveryCode: String!
}

input LoginUserWithTwoFactorCodeInput {
  authenticatorCode: String!
  rememberMachine: Boolean!
  rememberMe: Boolean!
}

input MethodCategoryOperationFilterInput {
  eq: MethodCategory
  in: [MethodCategory!]
  neq: MethodCategory
  nin: [MethodCategory!]
}

input MethodFilterInput {
  and: [MethodFilterInput!]
  categories: ListMethodCategoryOperationFilterInput
  description: StringOperationFilterInput
  id: ComparableGuidOperationFilterInput
  name: StringOperationFilterInput
  or: [MethodFilterInput!]
}

input MethodSortInput {
  availability: SortEnumType
  calculationLocator: UriSortInput
  description: SortEnumType
  id: SortEnumType
  manager: InstitutionSortInput
  managerId: SortEnumType
  name: SortEnumType
  publication: PublicationSortInput
  reference: IReferenceSortInput
  standard: StandardSortInput
  validity: SortEnumType
  xmin: SortEnumType
}

input NumerationSortInput {
  mainNumber: SortEnumType
  prefix: SortEnumType
  suffix: SortEnumType
}

input OpenEndedDateTimeRangeInput {
  from: DateTime
  to: DateTime
}

input OpticalDataPropositionInput {
  and: [OpticalDataPropositionInput!]
  componentId: UuidPropositionInput
  nearnormalHemisphericalVisibleTransmittance: FloatPropositionInput
  not: OpticalDataPropositionInput
  or: [OpticalDataPropositionInput!]
}

input PhotovoltaicDataPropositionInput {
  and: [PhotovoltaicDataPropositionInput!]
  componentId: UuidPropositionInput
  not: PhotovoltaicDataPropositionInput
  or: [PhotovoltaicDataPropositionInput!]
}

input PublicationSortInput {
  abstract: SortEnumType
  "A free and open-access archive for publications is offered by arXiv.org. The arXiv identifier can be used to define a publication."
  arXiv: SortEnumType
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: SortEnumType
  "Referenced section"
  section: SortEnumType
  title: SortEnumType
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: SortEnumType
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: UriSortInput
}

input RegisterUserInput {
  email: String!
  name: String!
  password: String!
  passwordConfirmation: String!
}

input RemoveInstitutionRepresentativeInput {
  institutionId: Uuid!
  userId: Uuid!
}

input RemoveUserRoleInput {
  role: UserRole!
  userId: Uuid!
}

input RequestUserPasswordResetInput {
  email: String!
}

input ResendUserEmailConfirmationInput {
  email: String!
}

input ResetUserPasswordInput {
  email: String!
  password: String!
  passwordConfirmation: String!
  resetCode: String!
}

input SetUserPasswordInput {
  password: String!
  passwordConfirmation: String!
}

input SetUserPhoneNumberInput {
  phoneNumber: String!
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
input StandardSortInput {
  abstract: SortEnumType
  locator: UriSortInput
  numeration: NumerationSortInput
  "The section of the standard to which the reference refers to."
  section: SortEnumType
  title: SortEnumType
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: SortEnumType
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

input UpdateInstitutionInput {
  abbreviation: String
  description: String!
  institutionId: Uuid!
  name: String!
  publicKey: String
  websiteLocator: Url
}

input UriFilterInput {
  absolutePath: StringOperationFilterInput
  absoluteUri: StringOperationFilterInput
  and: [UriFilterInput!]
  authority: StringOperationFilterInput
  dnsSafeHost: StringOperationFilterInput
  fragment: StringOperationFilterInput
  host: StringOperationFilterInput
  hostNameType: UriHostNameTypeOperationFilterInput
  idnHost: StringOperationFilterInput
  isAbsoluteUri: BooleanOperationFilterInput
  isDefaultPort: BooleanOperationFilterInput
  isFile: BooleanOperationFilterInput
  isLoopback: BooleanOperationFilterInput
  isUnc: BooleanOperationFilterInput
  localPath: StringOperationFilterInput
  or: [UriFilterInput!]
  originalString: StringOperationFilterInput
  pathAndQuery: StringOperationFilterInput
  port: ComparableInt32OperationFilterInput
  query: StringOperationFilterInput
  scheme: StringOperationFilterInput
  segments: ListStringOperationFilterInput
  userEscaped: BooleanOperationFilterInput
  userInfo: StringOperationFilterInput
}

input UriHostNameTypeOperationFilterInput {
  eq: UriHostNameType
  in: [UriHostNameType!]
  neq: UriHostNameType
  nin: [UriHostNameType!]
}

input UriSortInput {
  absolutePath: SortEnumType
  absoluteUri: SortEnumType
  authority: SortEnumType
  dnsSafeHost: SortEnumType
  fragment: SortEnumType
  host: SortEnumType
  hostNameType: SortEnumType
  idnHost: SortEnumType
  isAbsoluteUri: SortEnumType
  isDefaultPort: SortEnumType
  isFile: SortEnumType
  isLoopback: SortEnumType
  isUnc: SortEnumType
  localPath: SortEnumType
  originalString: SortEnumType
  pathAndQuery: SortEnumType
  port: SortEnumType
  query: SortEnumType
  scheme: SortEnumType
  userEscaped: SortEnumType
  userInfo: SortEnumType
}

input UserSortInput {
  accessFailedCount: SortEnumType
  concurrencyStamp: SortEnumType
  email: SortEnumType
  emailConfirmed: SortEnumType
  id: SortEnumType
  lockoutEnabled: SortEnumType
  lockoutEnd: SortEnumType
  "Full name"
  name: SortEnumType
  normalizedEmail: SortEnumType
  normalizedUserName: SortEnumType
  passwordHash: SortEnumType
  phoneNumber: SortEnumType
  phoneNumberConfirmed: SortEnumType
  postalAddress: SortEnumType
  securityStamp: SortEnumType
  twoFactorEnabled: SortEnumType
  userName: SortEnumType
  websiteLocator: UriSortInput
  xmin: SortEnumType
}

input UuidPropositionInput {
  equalTo: Uuid
}

input VerifyInstitutionInput {
  institutionId: Uuid!
}

enum AddInstitutionRepresentativeErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  DUPLICATE
  UNAUTHORIZED
}

enum AddUserRoleErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum ChangeInstitutionRepresentativeRoleErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_REPRESENTATIVE
  LAST_OWNER
}

enum ChangeUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_EMAIL
  INVALID_EMAIL
}

enum ChangeUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NO_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum ComponentCategory {
  MATERIAL
  LAYER
  UNIT
}

enum ConfirmComponentManufacturerErrorCode {
  UNKNOWN
  UNKNOWN_COMPONENT
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_MANUFACTURER
}

enum ConfirmInstitutionMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum ConfirmInstitutionRepresentativeErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_REPRESENTATIVE
}

enum ConfirmUserEmailChangeErrorCode {
  UNKNOWN
  DUPLICATE_EMAIL
  INVALID_CONFIRMATION_CODE
  UNKNOWN_USER
}

enum ConfirmUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  INVALID_CONFIRMATION_CODE
}

enum ConfirmUserMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum CreateComponentErrorCode {
  UNKNOWN
  UNKNOWN_MANUFACTURER
  UNAUTHORIZED
}

enum CreateDataFormatErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNKNOWN_MANAGER
  UNAUTHORIZED
}

enum CreateDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_OPERATOR
}

enum CreateInstitutionErrorCode {
  UNKNOWN
  NEITHER_OWNER_NOR_MANAGER
  UNKNOWN_OWNERS
  UNKNOWN_MANAGER
  UNAUTHORIZED
}

enum CreateMethodErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNKNOWN_MANAGER
  UNKNOWN_INSTITUTION_DEVELOPERS
  UNKNOWN_USER_DEVELOPERS
  UNAUTHORIZED
}

enum DeleteInstitutionErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
}

enum DeletePersonalUserDataErrorCode {
  UNKNOWN
  UNKNOWN_USER
  MISSING_PASSWORD
  INCORRECT_PASSWORD
}

enum DeleteUserErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

enum DisableUserTwoFactorAuthenticationErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum EnableUserTwoFactorAuthenticatorErrorCode {
  UNKNOWN
  UNKNOWN_USER
  ENABLING_FAILED
  INVALID_VERIFICATION_CODE
}

enum ForgetUserTwoFactorAuthenticationClientErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum GenerateUserTwoFactorRecoveryCodesErrorCode {
  UNKNOWN
  UNKNOWN_USER
  TWO_FACTOR_AUTHENTICATION_DISABLED
}

enum InstitutionRepresentativeRole {
  OWNER
  ASSISTANT
}

enum InstitutionState {
  PENDING
  VERIFIED
}

enum LoginUserErrorCode {
  INVALID
  LOCKED_OUT
  NOT_ALLOWED
  UNKNOWN
}

enum LoginUserWithRecoveryCodeErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NOT_ALLOWED
  LOCKED_OUT
  INVALID_RECOVERY_CODE
}

enum LoginUserWithTwoFactorCodeErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NOT_ALLOWED
  LOCKED_OUT
  INVALID_AUTHENTICATOR_CODE
}

enum LogoutUserErrorCode {
  UNKNOWN
}

enum MethodCategory {
  MEASUREMENT
  CALCULATION
}

enum RegisterUserErrorCode {
  UNKNOWN
  PASSWORD_CONFIRMATION_MISMATCH
  DUPLICATE_EMAIL
  INVALID_EMAIL
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
  NULL_OR_EMPTY_EMAIL
}

enum RemoveInstitutionRepresentativeErrorCode {
  UNKNOWN
  LAST_OWNER
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
  UNKNOWN_REPRESENTATIVE
  UNKNOWN_USER
}

enum RemoveUserRoleErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

enum RequestUserPasswordResetErrorCode {
  UNKNOWN
}

enum ResendUserEmailConfirmationErrorCode {
  UNKNOWN
}

enum ResendUserEmailVerificationErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum ResetUserPasswordErrorCode {
  UNKNOWN
  INVALID_RESET_CODE
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum ResetUserTwoFactorAuthenticatorErrorCode {
  UNKNOWN
  UNKNOWN_USER
  DISABLING_FAILED
  RESETTING_FAILED
}

enum SetUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  EXISTING_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum SetUserPhoneNumberErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_PHONE_NUMBER
}

enum SortEnumType {
  ASC
  DESC
}

enum Standardizer {
  AERC
  AGI
  ASHRAE
  BREEAM
  BS
  BSI
  CEN
  CIE
  DGNB
  DIN
  DVWG
  IEC
  IES
  IFT
  ISO
  JIS
  LEED
  NFRC
  RIBA
  UL
  UNECE
  VDI
  VFF
  WELL
}

enum UpdateInstitutionErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
}

enum UriHostNameType {
  UNKNOWN
  BASIC
  DNS
  I_PV4
  I_PV6
}

enum UserRole {
  ADMINISTRATOR
  VERIFIER
}

enum VerifyInstitutionErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
}

directive @authorize(
  "Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field."
  apply: ApplyPolicy! = BEFORE_RESOLVER
  "The name of the authorization policy that determines access to the annotated resource."
  policy: String
  "Roles that are allowed to access the annotated resource."
  roles: [String!]
) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer(
  "Deferred when true."
  if: Boolean
  "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to."
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy(
  "The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types."
  url: String!
) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream(
  "Streamed when true."
  if: Boolean!
  "The initial elements that shall be send down to the consumer."
  initialCount: Int!
  "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to."
  label: String
) on FIELD

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https://www.graphql-scalars.com/date-time")

"The NonNegativeInt scalar type represents a unsigned 32-bit numeric non-fractional value equal to or greater than 0."
scalar NonNegativeInt

scalar Url
