"""
Read-only GraphQL schema for the [metabase](https://www.buildingenvelopedata.org/graphql/) of the network of databases for [building envelope data](https://www.buildingenvelopedata.org). While the metabase stores meta information for example about components and institutions, the (child) databases store the data about building envelope components.

It follows best practices for
* [Global Object Identification](https://graphql.org/learn/global-object-identification/)
  as exemplified in
  [GraphQL Server Specification: Object Identification](https://relay.dev/docs/en/graphql-server-specification.html#object-identification)
  (see also [GraphQL Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)),
  and
* [Pagination](https://graphql.org/learn/pagination/),
  by adhering to the
  [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm),
  as exemplified in
  [GraphQL Server Specification: Connections](https://relay.dev/docs/en/graphql-server-specification.html#connections).

Global object identifiers as requird by the best practice are exposed by the
property `id` and universally unique identifiers as issued by the "metabase"
are exposed by the property `uuid`. In essence, `id` is the Base64-encoded
concatenation of `uuid` and the requested locale.

For interoperability with the (child) databases, implementations serve HTTP
requests as elaborated on
[Serving over HTTP](https://graphql.org/learn/serving-over-http/).

The
[Internet Engineering Task Force (IETF)](https://www.ietf.org)
is an Internet standards organization. It publishes standards in
[Request for Comments (RFC)](https://ietf.org/standards/rfcs/)
documents. They are
[searchable](https://www.rfc-editor.org/search/rfc_search.php)
and
[indexed](https://www.rfc-editor.org/rfc-index.html).
Examples are
[Hypertext Transfer Protocol (HTTP)](https://tools.ietf.org/html/rfc7231)
and
[Transport Layer Security (TLS)](https://tools.ietf.org/html/rfc8446).

The
[Internet Assigned Numbers Authority (IANA)](https://www.iana.org)
allocates and maintains unique codes and numbering systems that are used in
technical standards that drive the Internet like
[domain names](https://www.iana.org/domains),
[Internet Protocol addresses](https://www.iana.org/numbers), and
[registries](https://www.iana.org/protocols).
Examples of the last are
[HTTP status code registry](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)
and
[media type registry](https://www.iana.org/assignments/media-types/media-types.xhtml).

The
[International Organization for Standardization (ISO)](https://www.iso.org)
develops and publishes
[International Standards](https://www.iso.org/standards-catalogue/browse-by-ics.html).
Examples are
[ISO 8601 Date And Time Format](https://www.iso.org/iso-8601-date-and-time-format.html)
and
[ISO 3166 Country Codes](https://www.iso.org/iso-3166-country-codes.html).

The library
[graphql-scalars](https://github.com/Urigo/graphql-scalars)
introduces custom scalar types for creating precise type-safe GraphQL schemas.
We took some inspiration from
[GitHub GraphQL API](https://docs.github.com/en/graphql).
"""
scalar Schema

schema {
  query: Query
  mutation: Mutation
}

interface Data {
  appliedMethod: AppliedMethod!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  databaseId: Uuid!
  description: String
  locale: String!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface Reference {
  abstract: String
  section: String
  title: String
}

interface Stakeholder {
  name: String!
}

type AddComponentAssemblyError {
  code: AddComponentAssemblyErrorCode!
  message: String!
  path: [String!]!
}

type AddComponentAssemblyPayload {
  assembledOfEdge: ComponentAssembledOfEdge
  errors: [AddComponentAssemblyError!]
  partOfEdge: ComponentPartOfEdge
  query: Query!
}

type AddComponentGeneralizationError {
  code: AddComponentGeneralizationErrorCode!
  message: String!
  path: [String!]!
}

type AddComponentGeneralizationPayload {
  concretizationOfEdge: ComponentConcretizationOfEdge
  errors: [AddComponentGeneralizationError!]
  generalizationOfEdge: ComponentGeneralizationOfEdge
  query: Query!
}

type AddComponentManufacturerError {
  code: AddComponentManufacturerErrorCode!
  message: String!
  path: [String!]!
}

type AddComponentManufacturerPayload {
  componentManufacturerEdge: ComponentManufacturerEdge
  errors: [AddComponentManufacturerError!]
  manufacturedComponentEdge: InstitutionManufacturedComponentEdge
  query: Query!
}

type AddComponentVariantError {
  code: AddComponentVariantErrorCode!
  message: String!
  path: [String!]!
}

type AddComponentVariantPayload {
  errors: [AddComponentVariantError!]
  query: Query!
  reverseVariantOfEdge: ComponentVariantOfEdge
  variantOfEdge: ComponentVariantOfEdge
}

type AddInstitutionMethodDeveloperError {
  code: AddInstitutionMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type AddInstitutionMethodDeveloperPayload {
  developedMethodEdge: InstitutionDevelopedMethodEdge
  errors: [AddInstitutionMethodDeveloperError!]
  methodDeveloperEdge: InstitutionMethodDeveloperEdge
  query: Query!
}

type AddInstitutionRepresentativeError {
  code: AddInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type AddInstitutionRepresentativePayload {
  errors: [AddInstitutionRepresentativeError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  query: Query!
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type AddUserMethodDeveloperError {
  code: AddUserMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type AddUserMethodDeveloperPayload {
  developedMethodEdge: UserDevelopedMethodEdge
  errors: [AddUserMethodDeveloperError!]
  methodDeveloperEdge: UserMethodDeveloperEdge
  query: Query!
}

type AddUserRoleError {
  code: AddUserRoleErrorCode!
  message: String!
  path: [String!]!
}

type AddUserRolePayload {
  errors: [AddUserRoleError!]
  query: Query!
  user: User
}

type AppliedMethod {
  arguments: [NamedMethodArgument!]!
  method: Method @cost(weight: "10")
  methodId: Uuid!
  sources: [NamedMethodSource!]!
}

type CalorimetricData implements Data {
  appliedMethod: AppliedMethod!
  component: Component @cost(weight: "10")
  componentId: Uuid!
  createdAt: DateTime!
  creator: Institution @cost(weight: "10")
  creatorId: Uuid!
  database: Database @cost(weight: "10")
  databaseId: Uuid!
  description: String
  gValues: [Float!]!
  id: String!
  locale: String!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  uValues: [Float!]!
  warnings: [String!]!
}

type CalorimetricDataConnection {
  edges: [CalorimetricDataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type CalorimetricDataEdge {
  cursor: String!
  node: CalorimetricData!
}

type ChangeInstitutionRepresentativeRoleError {
  code: ChangeInstitutionRepresentativeRoleErrorCode!
  message: String!
  path: [String!]!
}

type ChangeInstitutionRepresentativeRolePayload {
  errors: [ChangeInstitutionRepresentativeRoleError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  query: Query!
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type ChangeUserEmailError {
  code: ChangeUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserEmailPayload {
  errors: [ChangeUserEmailError!]
  query: Query!
  user: User
}

type ChangeUserPasswordError {
  code: ChangeUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ChangeUserPasswordPayload {
  errors: [ChangeUserPasswordError!]
  query: Query!
  user: User
}

type CielabColor {
  aStar: Float!
  bStar: Float!
  lStar: Float!
}

type Component implements Node {
  abbreviation: String
  assembledOf: ComponentAssembledOfConnection! @cost(weight: "10")
  availability: OpenEndedDateTimeRange
  canCurrentUserUpdateNode: Boolean! @cost(weight: "10")
  categories: [ComponentCategory!]!
  concretizationOf: ComponentConcretizationOfConnection! @cost(weight: "10")
  description: String!
  generalizationOf: ComponentGeneralizationOfConnection! @cost(weight: "10")
  id: ID!
  manufacturers(pending: Boolean! = false): ComponentManufacturerConnection! @cost(weight: "10")
  name: String!
  partOf: ComponentPartOfConnection! @cost(weight: "10")
  uuid: Uuid! @cost(weight: "10")
  variantOf: ComponentVariantOfConnection! @cost(weight: "10")
}

type ComponentAssembledOfConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentAssembledOfEdge!]! @cost(weight: "10")
}

type ComponentAssembledOfEdge {
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  canCurrentUserUpdateEdge: Boolean! @cost(weight: "10")
  index: Byte
  node: Component! @cost(weight: "10")
  primeSurface: PrimeSurface
}

type ComponentConcretizationOfConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentConcretizationOfEdge!]! @cost(weight: "10")
}

type ComponentConcretizationOfEdge {
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Component! @cost(weight: "10")
}

type ComponentGeneralizationOfConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentGeneralizationOfEdge!]! @cost(weight: "10")
}

type ComponentGeneralizationOfEdge {
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Component! @cost(weight: "10")
}

type ComponentManufacturerConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentManufacturerEdge!]! @cost(weight: "10")
}

type ComponentManufacturerEdge {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Institution! @cost(weight: "10")
}

type ComponentPartOfConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentPartOfEdge!]! @cost(weight: "10")
}

type ComponentPartOfEdge {
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  canCurrentUserUpdateEdge: Boolean! @cost(weight: "10")
  index: Byte
  node: Component! @cost(weight: "10")
  primeSurface: PrimeSurface
}

type ComponentVariantOfConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [ComponentVariantOfEdge!]! @cost(weight: "10")
}

type ComponentVariantOfEdge {
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Component! @cost(weight: "10")
}

"A connection to a list of items."
type ComponentsConnection {
  "A list of edges."
  edges: [ComponentsEdge!]
  "A flattened list of the nodes."
  nodes: [Component!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type ComponentsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Component!
}

type ConfirmComponentManufacturerError {
  code: ConfirmComponentManufacturerErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmComponentManufacturerPayload {
  componentManufacturerEdge: ComponentManufacturerEdge
  errors: [ConfirmComponentManufacturerError!]
  manufacturedComponentEdge: InstitutionManufacturedComponentEdge
  query: Query!
}

type ConfirmInstitutionMethodDeveloperError {
  code: ConfirmInstitutionMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmInstitutionMethodDeveloperPayload {
  developedMethodEdge: InstitutionDevelopedMethodEdge
  errors: [ConfirmInstitutionMethodDeveloperError!]
  methodDeveloperEdge: InstitutionMethodDeveloperEdge
  query: Query!
}

type ConfirmInstitutionRepresentativeError {
  code: ConfirmInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmInstitutionRepresentativePayload {
  errors: [ConfirmInstitutionRepresentativeError!]
  institutionRepresentativeEdge: InstitutionRepresentativeEdge
  query: Query!
  representedInstitutionEdge: UserRepresentedInstitutionEdge
}

type ConfirmUserEmailChangeError {
  code: ConfirmUserEmailChangeErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailChangePayload {
  errors: [ConfirmUserEmailChangeError!]
  query: Query!
  user: User
}

type ConfirmUserEmailError {
  code: ConfirmUserEmailErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserEmailPayload {
  errors: [ConfirmUserEmailError!]
  query: Query!
  user: User
}

type ConfirmUserMethodDeveloperError {
  code: ConfirmUserMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type ConfirmUserMethodDeveloperPayload {
  developedMethodEdge: UserDevelopedMethodEdge
  errors: [ConfirmUserMethodDeveloperError!]
  methodDeveloperEdge: UserMethodDeveloperEdge
  query: Query!
}

type CreateComponentError {
  code: CreateComponentErrorCode!
  message: String!
  path: [String!]!
}

type CreateComponentPayload {
  component: Component
  errors: [CreateComponentError!]
  query: Query!
}

type CreateDataFormatError {
  code: CreateDataFormatErrorCode!
  message: String!
  path: [String!]!
}

type CreateDataFormatPayload {
  dataFormat: DataFormat
  errors: [CreateDataFormatError!]
  query: Query!
}

type CreateDatabaseError {
  code: CreateDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type CreateDatabasePayload {
  database: Database
  errors: [CreateDatabaseError!]
  query: Query!
}

type CreateInstitutionError {
  code: CreateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type CreateInstitutionPayload {
  errors: [CreateInstitutionError!]
  institution: Institution
  query: Query!
}

type CreateMethodError {
  code: CreateMethodErrorCode!
  message: String!
  path: [String!]!
}

type CreateMethodPayload {
  errors: [CreateMethodError!]
  method: Method
  query: Query!
}

type CrossDatabaseDataReference {
  database: Institution @cost(weight: "10")
  databaseId: Uuid!
  dataId: Uuid!
  dataKind: DataKind!
  dataTimestamp: DateTime!
}

type DataApproval {
  approver: Institution @cost(weight: "10")
  approverId: Uuid!
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

type DataConnection {
  edges: [DataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type DataEdge {
  cursor: String!
  node: Data!
}

type DataFormat implements Node {
  canCurrentUserUpdateNode: Boolean! @cost(weight: "10")
  description: String!
  extension: String
  id: ID!
  manager: DataFormatManagerEdge! @cost(weight: "10")
  mediaType: String!
  name: String!
  reference: Reference
  schemaLocator: Url
  uuid: Uuid! @cost(weight: "10")
}

type DataFormatManagerEdge {
  node: Institution! @cost(weight: "10")
}

"A connection to a list of items."
type DataFormatsConnection {
  "A list of edges."
  edges: [DataFormatsEdge!]
  "A flattened list of the nodes."
  nodes: [DataFormat!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type DataFormatsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DataFormat!
}

type Database implements Node {
  allCalorimetricData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: CalorimetricDataPropositionInput): CalorimetricDataConnection @cost(weight: "10")
  allData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: DataPropositionInput): DataConnection @cost(weight: "10")
  allGeometricData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: GeometricDataPropositionInput): GeometricDataConnection @cost(weight: "10")
  allHygrothermalData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: HygrothermalDataPropositionInput): HygrothermalDataConnection @cost(weight: "10")
  allOpticalData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: OpticalDataPropositionInput): OpticalDataConnection @cost(weight: "10")
  allPhotovoltaicData(after: String before: String first: NonNegativeInt last: NonNegativeInt locale: String timestamp: DateTime where: PhotovoltaicDataPropositionInput): PhotovoltaicDataConnection @cost(weight: "10")
  calorimetricData(id: Uuid! locale: String timestamp: DateTime): CalorimetricData @cost(weight: "10")
  canCurrentUserUpdateNode: Boolean! @cost(weight: "10")
  canCurrentUserVerifyNode: Boolean! @cost(weight: "10")
  data(id: Uuid! locale: String timestamp: DateTime): Data @cost(weight: "10")
  description: String!
  geometricData(id: Uuid! locale: String timestamp: DateTime): GeometricData @cost(weight: "10")
  hasCalorimetricData(locale: String timestamp: DateTime where: CalorimetricDataPropositionInput): Boolean @cost(weight: "10")
  hasData(locale: String timestamp: DateTime where: DataPropositionInput): Boolean @cost(weight: "10")
  hasGeometricData(locale: String timestamp: DateTime where: GeometricDataPropositionInput): Boolean @cost(weight: "10")
  hasHygrothermalData(locale: String timestamp: DateTime where: HygrothermalDataPropositionInput): Boolean @cost(weight: "10")
  hasOpticalData(locale: String timestamp: DateTime where: OpticalDataPropositionInput): Boolean @cost(weight: "10")
  hasPhotovoltaicData(locale: String timestamp: DateTime where: PhotovoltaicDataPropositionInput): Boolean @cost(weight: "10")
  hygrothermalData(id: Uuid! locale: String timestamp: DateTime): HygrothermalData @cost(weight: "10")
  id: ID!
  locator: Url!
  name: String!
  operator: DatabaseOperatorEdge! @cost(weight: "10")
  opticalData(id: Uuid! locale: String timestamp: DateTime): OpticalData @cost(weight: "10")
  photovoltaicData(id: Uuid! locale: String timestamp: DateTime): PhotovoltaicData @cost(weight: "10")
  uuid: Uuid! @cost(weight: "10")
  verificationCode: String!
  verificationState: DatabaseVerificationState!
}

type DatabaseOperatorEdge {
  node: Institution! @cost(weight: "10")
}

"A connection to a list of items."
type DatabasesConnection {
  "A list of edges."
  edges: [DatabasesEdge!]
  "A flattened list of the nodes."
  nodes: [Database!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type DatabasesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Database!
}

type DeleteInstitutionError {
  code: DeleteInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type DeleteInstitutionPayload {
  errors: [DeleteInstitutionError!]
  query: Query!
}

type DeletePersonalUserDataError {
  code: DeletePersonalUserDataErrorCode!
  message: String!
  path: [String!]!
}

type DeletePersonalUserDataPayload {
  errors: [DeletePersonalUserDataError!]
  query: Query!
  user: User
}

type DeleteUserError {
  code: DeleteUserErrorCode!
  message: String!
  path: [String!]!
}

type DeleteUserPayload {
  errors: [DeleteUserError!]
  query: Query!
  user: User
}

type DisableUserTwoFactorAuthenticationError {
  code: DisableUserTwoFactorAuthenticationErrorCode!
  message: String!
  path: [String!]!
}

type DisableUserTwoFactorAuthenticationPayload {
  errors: [DisableUserTwoFactorAuthenticationError!]
  query: Query!
  user: User
}

type EnableUserTwoFactorAuthenticatorError {
  code: EnableUserTwoFactorAuthenticatorErrorCode!
  message: String!
  path: [String!]!
}

type EnableUserTwoFactorAuthenticatorPayload {
  authenticatorUri: String
  errors: [EnableUserTwoFactorAuthenticatorError!]
  query: Query!
  sharedKey: String
  twoFactorRecoveryCodes: [String!]
  user: User
}

type FileMetaInformation {
  dataFormat: DataFormat @cost(weight: "10")
  dataFormatId: Uuid!
  path: [String!]!
}

type ForgetUserTwoFactorAuthenticationClientError {
  code: ForgetUserTwoFactorAuthenticationClientErrorCode!
  message: String!
  path: [String!]!
}

type ForgetUserTwoFactorAuthenticationClientPayload {
  errors: [ForgetUserTwoFactorAuthenticationClientError!]
  query: Query!
  user: User
}

type GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriError {
  code: GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriErrorCode!
  message: String!
  path: [String!]!
}

type GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriPayload {
  authenticatorUri: String
  errors: [GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriError!]
  query: Query!
  sharedKey: String
  user: User
}

type GenerateUserTwoFactorRecoveryCodesError {
  code: GenerateUserTwoFactorRecoveryCodesErrorCode!
  message: String!
  path: [String!]!
}

type GenerateUserTwoFactorRecoveryCodesPayload {
  errors: [GenerateUserTwoFactorRecoveryCodesError!]
  query: Query!
  twoFactorRecoveryCodes: [String!]
  user: User
}

type GeometricData implements Data {
  appliedMethod: AppliedMethod!
  component: Component @cost(weight: "10")
  componentId: Uuid!
  createdAt: DateTime!
  creator: Institution @cost(weight: "10")
  creatorId: Uuid!
  database: Database @cost(weight: "10")
  databaseId: Uuid!
  description: String
  id: String!
  locale: String!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  thicknesses: [Float!]!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

type GeometricDataConnection {
  edges: [GeometricDataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type GeometricDataEdge {
  cursor: String!
  node: GeometricData!
}

type GetHttpsResource {
  archivedFilesMetaInformation: [FileMetaInformation!]!
  dataFormat: DataFormat @cost(weight: "10")
  dataFormatId: Uuid!
  description: String!
  hashValue: String!
  locator: Url!
}

type GetHttpsResourceTree {
  nonRootVertices: [GetHttpsResourceTreeNonRootVertex!]!
  root: GetHttpsResourceTreeRoot!
}

type GetHttpsResourceTreeNonRootVertex {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod!
  parentId: String!
  value: GetHttpsResource!
  vertexId: String!
}

type GetHttpsResourceTreeRoot {
  value: GetHttpsResource!
  vertexId: String!
}

type HygrothermalData implements Data {
  appliedMethod: AppliedMethod!
  component: Component @cost(weight: "10")
  componentId: Uuid!
  createdAt: DateTime!
  creator: Institution @cost(weight: "10")
  creatorId: Uuid!
  database: Database @cost(weight: "10")
  databaseId: Uuid!
  description: String
  id: String!
  locale: String!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

type HygrothermalDataConnection {
  edges: [HygrothermalDataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type HygrothermalDataEdge {
  cursor: String!
  node: HygrothermalData!
}

type Institution implements Node & Stakeholder {
  abbreviation: String
  canCurrentUserDeleteNode: Boolean! @cost(weight: "10")
  canCurrentUserSwitchOperatingStateOfNode: Boolean! @cost(weight: "10")
  canCurrentUserUpdateNode: Boolean! @cost(weight: "10")
  description: String!
  developedMethods(pending: Boolean! = false): InstitutionDevelopedMethodConnection! @cost(weight: "10")
  id: ID!
  managedDataFormats: InstitutionManagedDataFormatConnection! @cost(weight: "10")
  managedInstitutions: InstitutionManagedInstitutionConnection! @cost(weight: "10")
  managedMethods: InstitutionManagedMethodConnection! @cost(weight: "10")
  manager: InstitutionManagerEdge @cost(weight: "10")
  manufacturedComponents(pending: Boolean! = false): InstitutionManufacturedComponentConnection! @cost(weight: "10")
  name: String!
  operatedDatabases: InstitutionOperatedDatabaseConnection! @cost(weight: "10")
  operatingState: InstitutionOperatingState!
  publicKey: String
  representatives(pending: Boolean! = false): InstitutionRepresentativeConnection! @cost(weight: "10")
  state: InstitutionState!
  uuid: Uuid! @cost(weight: "10")
  websiteLocator: Url
}

type InstitutionDevelopedMethodConnection {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionDevelopedMethodEdge!]! @cost(weight: "10")
}

type InstitutionDevelopedMethodEdge {
  node: Method! @cost(weight: "10")
}

type InstitutionManagedDataFormatConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionManagedDataFormatEdge!]! @cost(weight: "10")
}

type InstitutionManagedDataFormatEdge {
  node: DataFormat!
}

type InstitutionManagedInstitutionConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionManagedInstitutionEdge!]! @cost(weight: "10")
}

type InstitutionManagedInstitutionEdge {
  node: Institution!
}

type InstitutionManagedMethodConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionManagedMethodEdge!]! @cost(weight: "10")
}

type InstitutionManagedMethodEdge {
  node: Method!
}

type InstitutionManagerEdge {
  node: Institution! @cost(weight: "10")
}

type InstitutionManufacturedComponentConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionManufacturedComponentEdge!]! @cost(weight: "10")
}

type InstitutionManufacturedComponentEdge {
  node: Component! @cost(weight: "10")
}

type InstitutionMethodDeveloperEdge {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Institution! @cost(weight: "10")
}

type InstitutionOperatedDatabaseConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionOperatedDatabaseEdge!]! @cost(weight: "10")
}

type InstitutionOperatedDatabaseEdge {
  node: Database!
}

type InstitutionRepresentativeConnection {
  canCurrentUserAddEdge: Boolean! @cost(weight: "10")
  edges: [InstitutionRepresentativeEdge!]! @cost(weight: "10")
}

type InstitutionRepresentativeEdge {
  node: User! @cost(weight: "10")
  role: InstitutionRepresentativeRole!
}

"A connection to a list of items."
type InstitutionsConnection {
  "A list of edges."
  edges: [InstitutionsEdge!]
  "A flattened list of the nodes."
  nodes: [Institution!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type InstitutionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Institution!
}

type LoginUserError {
  code: LoginUserErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserPayload {
  errors: [LoginUserError!]
  query: Query!
  requiresTwoFactor: Boolean
  user: User
}

type LoginUserWithRecoveryCodeError {
  code: LoginUserWithRecoveryCodeErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserWithRecoveryCodePayload {
  errors: [LoginUserWithRecoveryCodeError!]
  query: Query!
  user: User
}

type LoginUserWithTwoFactorCodeError {
  code: LoginUserWithTwoFactorCodeErrorCode!
  message: String!
  path: [String!]!
}

type LoginUserWithTwoFactorCodePayload {
  errors: [LoginUserWithTwoFactorCodeError!]
  query: Query!
  user: User
}

type LogoutUserError {
  code: LogoutUserErrorCode!
  message: String!
  path: [String!]!
}

type LogoutUserPayload {
  errors: [LogoutUserError!]
  query: Query!
  user: User
}

type Method implements Node {
  availability: OpenEndedDateTimeRange
  calculationLocator: Url
  canCurrentUserUpdateNode: Boolean! @cost(weight: "10")
  categories: [MethodCategory!]!
  description: String!
  developers(pending: Boolean! = false): MethodDeveloperConnection! @cost(weight: "10")
  id: ID!
  manager: MethodManagerEdge! @cost(weight: "10")
  name: String!
  reference: Reference
  uuid: Uuid! @cost(weight: "10")
  validity: OpenEndedDateTimeRange
}

type MethodDeveloperConnection {
  canCurrentUserAddInstitutionEdge: Boolean! @cost(weight: "10")
  canCurrentUserAddUserEdge: Boolean! @cost(weight: "10")
  edges: [MethodDeveloperEdge!]! @cost(weight: "10")
}

type MethodDeveloperEdge {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: Stakeholder! @cost(weight: "10")
}

type MethodManagerEdge {
  node: Institution! @cost(weight: "10")
}

"A connection to a list of items."
type MethodsConnection {
  "A list of edges."
  edges: [MethodsEdge!]
  "A flattened list of the nodes."
  nodes: [Method!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type MethodsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Method!
}

type Mutation {
  addComponentAssembly(input: AddComponentAssemblyInput!): AddComponentAssemblyPayload! @authorize(policy: "Write") @cost(weight: "10")
  addComponentGeneralization(input: AddComponentGeneralizationInput!): AddComponentGeneralizationPayload! @authorize(policy: "Write") @cost(weight: "10")
  addComponentManufacturer(input: AddComponentManufacturerInput!): AddComponentManufacturerPayload! @authorize(policy: "Write") @cost(weight: "10")
  addComponentVariant(input: AddComponentVariantInput!): AddComponentVariantPayload! @authorize(policy: "Write") @cost(weight: "10")
  addInstitutionMethodDeveloper(input: AddInstitutionMethodDeveloperInput!): AddInstitutionMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  addInstitutionRepresentative(input: AddInstitutionRepresentativeInput!): AddInstitutionRepresentativePayload! @authorize(policy: "Write") @cost(weight: "10")
  addUserMethodDeveloper(input: AddUserMethodDeveloperInput!): AddUserMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  addUserRole(input: AddUserRoleInput!): AddUserRolePayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  changeInstitutionRepresentativeRole(input: ChangeInstitutionRepresentativeRoleInput!): ChangeInstitutionRepresentativeRolePayload! @authorize(policy: "Write") @cost(weight: "10")
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  confirmComponentManufacturer(input: ConfirmComponentManufacturerInput!): ConfirmComponentManufacturerPayload! @authorize(policy: "Write") @cost(weight: "10")
  confirmInstitutionMethodDeveloper(input: ConfirmInstitutionMethodDeveloperInput!): ConfirmInstitutionMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  confirmInstitutionRepresentative(input: ConfirmInstitutionRepresentativeInput!): ConfirmInstitutionRepresentativePayload! @authorize(policy: "Write") @cost(weight: "10")
  confirmUserEmail(input: ConfirmUserEmailInput!): ConfirmUserEmailPayload! @cost(weight: "10")
  confirmUserEmailChange(input: ConfirmUserEmailChangeInput!): ConfirmUserEmailChangePayload! @cost(weight: "10")
  confirmUserMethodDeveloper(input: ConfirmUserMethodDeveloperInput!): ConfirmUserMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  createComponent(input: CreateComponentInput!): CreateComponentPayload! @authorize(policy: "Write") @cost(weight: "10")
  createDatabase(input: CreateDatabaseInput!): CreateDatabasePayload! @authorize(policy: "Write") @cost(weight: "10")
  createDataFormat(input: CreateDataFormatInput!): CreateDataFormatPayload! @authorize(policy: "Write") @cost(weight: "10")
  createInstitution(input: CreateInstitutionInput!): CreateInstitutionPayload! @authorize(policy: "Write") @cost(weight: "10")
  createMethod(input: CreateMethodInput!): CreateMethodPayload! @authorize(policy: "Write") @cost(weight: "10")
  deleteInstitution(input: DeleteInstitutionInput!): DeleteInstitutionPayload! @authorize(policy: "Write") @cost(weight: "10")
  deletePersonalUserData(input: DeletePersonalUserDataInput!): DeletePersonalUserDataPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  deleteUser(input: DeleteUserInput!): DeleteUserPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  disableUserTwoFactorAuthentication: DisableUserTwoFactorAuthenticationPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  enableUserTwoFactorAuthenticator(input: EnableUserTwoFactorAuthenticatorInput!): EnableUserTwoFactorAuthenticatorPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  forgetUserTwoFactorAuthenticationClient: ForgetUserTwoFactorAuthenticationClientPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  generateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUri: GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  generateUserTwoFactorRecoveryCodes: GenerateUserTwoFactorRecoveryCodesPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  loginUser(input: LoginUserInput!): LoginUserPayload! @cost(weight: "10")
  loginUserWithRecoveryCode(input: LoginUserWithRecoveryCodeInput!): LoginUserWithRecoveryCodePayload! @cost(weight: "10")
  loginUserWithTwoFactorCode(input: LoginUserWithTwoFactorCodeInput!): LoginUserWithTwoFactorCodePayload! @cost(weight: "10")
  logoutUser: LogoutUserPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  registerUser(input: RegisterUserInput!): RegisterUserPayload! @cost(weight: "10")
  removeComponentAssembly(input: RemoveComponentAssemblyInput!): RemoveComponentAssemblyPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeComponentGeneralization(input: RemoveComponentGeneralizationInput!): RemoveComponentGeneralizationPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeComponentManufacturer(input: RemoveComponentManufacturerInput!): RemoveComponentManufacturerPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeComponentVariant(input: RemoveComponentVariantInput!): RemoveComponentVariantPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeInstitutionMethodDeveloper(input: RemoveInstitutionMethodDeveloperInput!): RemoveInstitutionMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeInstitutionRepresentative(input: RemoveInstitutionRepresentativeInput!): RemoveInstitutionRepresentativePayload! @authorize(policy: "Write") @cost(weight: "10")
  removeUserMethodDeveloper(input: RemoveUserMethodDeveloperInput!): RemoveUserMethodDeveloperPayload! @authorize(policy: "Write") @cost(weight: "10")
  removeUserRole(input: RemoveUserRoleInput!): RemoveUserRolePayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  requestUserPasswordReset(input: RequestUserPasswordResetInput!): RequestUserPasswordResetPayload! @cost(weight: "10")
  resendUserEmailConfirmation(input: ResendUserEmailConfirmationInput!): ResendUserEmailConfirmationPayload! @cost(weight: "10")
  resendUserEmailVerification: ResendUserEmailVerificationPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  resetUserPassword(input: ResetUserPasswordInput!): ResetUserPasswordPayload! @cost(weight: "10")
  resetUserTwoFactorAuthenticator: ResetUserTwoFactorAuthenticatorPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  setUserPassword(input: SetUserPasswordInput!): SetUserPasswordPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  setUserPhoneNumber(input: SetUserPhoneNumberInput!): SetUserPhoneNumberPayload! @authorize(policy: "ManageUser") @cost(weight: "10")
  switchInstitutionOperatingState(input: SwitchInstitutionOperatingStateInput!): SwitchInstitutionOperatingStatePayload! @authorize(policy: "Write") @cost(weight: "10")
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload! @authorize(policy: "Write") @cost(weight: "10")
  updateComponentAssembly(input: UpdateComponentAssemblyInput!): UpdateComponentAssemblyPayload! @authorize(policy: "Write") @cost(weight: "10")
  updateDatabase(input: UpdateDatabaseInput!): UpdateDatabasePayload! @authorize(policy: "Write") @cost(weight: "10")
  updateDataFormat(input: UpdateDataFormatInput!): UpdateDataFormatPayload! @authorize(policy: "Write") @cost(weight: "10")
  updateInstitution(input: UpdateInstitutionInput!): UpdateInstitutionPayload! @authorize(policy: "Write") @cost(weight: "10")
  updateMethod(input: UpdateMethodInput!): UpdateMethodPayload! @authorize(policy: "Write") @cost(weight: "10")
  verifyDatabase(input: VerifyDatabaseInput!): VerifyDatabasePayload! @authorize(policy: "Write") @cost(weight: "10")
  verifyInstitution(input: VerifyInstitutionInput!): VerifyInstitutionPayload! @authorize(policy: "Write") @cost(weight: "10")
}

type NamedMethodArgument {
  name: String!
  value: Any!
}

type NamedMethodSource {
  name: String!
  value: CrossDatabaseDataReference!
}

type Numeration {
  mainNumber: String!
  prefix: String
  suffix: String
}

type OpenEndedDateTimeRange {
  from: DateTime @cost(weight: "10")
  to: DateTime @cost(weight: "10")
}

type OpenIdConnectApplication {
  applicationType: String
  authorizations: [OpenIdConnectAuthorization!]!
  clientId: String
  clientSecret: String
  clientType: String
  concurrencyToken: String
  consentType: String
  displayName: String
  displayNames: String
  id: String
  jsonWebKeySet: String
  permissions: String
  postLogoutRedirectUris: String
  properties: String
  redirectUris: String
  requirements: String
  settings: String
  tokens: [OpenIdConnectToken!]!
}

type OpenIdConnectAuthorization {
  application: OpenIdConnectApplication
  concurrencyToken: String
  creationDate: DateTime
  id: String
  properties: String
  scopes: String
  status: String
  subject: String
  tokens: [OpenIdConnectToken!]!
  type: String
}

type OpenIdConnectScope {
  concurrencyToken: String
  description: String
  descriptions: String
  displayName: String
  displayNames: String
  id: String
  name: String
  properties: String
  resources: String
}

type OpenIdConnectToken {
  application: OpenIdConnectApplication
  authorization: OpenIdConnectAuthorization
  concurrencyToken: String
  creationDate: DateTime
  expirationDate: DateTime
  id: String
  payload: String
  properties: String
  redemptionDate: DateTime
  referenceId: String
  status: String
  subject: String
  type: String
}

type OpticalData implements Data {
  appliedMethod: AppliedMethod!
  cielabColors: [CielabColor!]!
  colorRenderingIndices: [Float!]!
  component: Component @cost(weight: "10")
  componentId: Uuid!
  createdAt: DateTime!
  creator: Institution @cost(weight: "10")
  creatorId: Uuid!
  database: Database @cost(weight: "10")
  databaseId: Uuid!
  description: String
  id: String!
  infraredEmittances: [Float!]!
  locale: String!
  name: String
  nearnormalHemisphericalSolarReflectances: [Float!]!
  nearnormalHemisphericalSolarTransmittances: [Float!]!
  nearnormalHemisphericalVisibleReflectances: [Float!]!
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

type OpticalDataConnection {
  edges: [OpticalDataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type OpticalDataEdge {
  cursor: String!
  node: OpticalData!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"A connection to a list of items."
type PendingDatabasesConnection {
  "A list of edges."
  edges: [PendingDatabasesEdge!]
  "A flattened list of the nodes."
  nodes: [Database!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type PendingDatabasesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Database!
}

"A connection to a list of items."
type PendingInstitutionsConnection {
  "A list of edges."
  edges: [PendingInstitutionsEdge!]
  "A flattened list of the nodes."
  nodes: [Institution!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type PendingInstitutionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Institution!
}

type PhotovoltaicData implements Data {
  appliedMethod: AppliedMethod!
  component: Component @cost(weight: "10")
  componentId: Uuid!
  createdAt: DateTime!
  creator: Institution @cost(weight: "10")
  creatorId: Uuid!
  database: Database @cost(weight: "10")
  databaseId: Uuid!
  description: String
  id: String!
  locale: String!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

type PhotovoltaicDataConnection {
  edges: [PhotovoltaicDataEdge!]!
  timestamp: DateTime!
  totalCount: NonNegativeInt
}

type PhotovoltaicDataEdge {
  cursor: String!
  node: PhotovoltaicData!
}

type Publication implements Reference {
  abstract: String
  "The website arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: String
  authors: [String!]
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: String
  "Referenced section"
  section: String
  title: String
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: String
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: Url
}

type Query {
  component(uuid: Uuid!): Component @cost(weight: "10")
  components("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [ComponentSortInput!] @cost(weight: "10") where: ComponentFilterInput @cost(weight: "10")): ComponentsConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  currentUser: User @cost(weight: "10")
  database(uuid: Uuid!): Database @cost(weight: "10")
  databases("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [DatabaseSortInput!] @cost(weight: "10") where: DatabaseFilterInput @cost(weight: "10")): DatabasesConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  dataFormat(uuid: Uuid!): DataFormat @cost(weight: "10")
  dataFormats("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [DataFormatSortInput!] @cost(weight: "10") where: DataFormatFilterInput @cost(weight: "10")): DataFormatsConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  institution(uuid: Uuid!): Institution @cost(weight: "10")
  institutions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [InstitutionSortInput!] @cost(weight: "10") where: InstitutionFilterInput @cost(weight: "10")): InstitutionsConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  method(uuid: Uuid!): Method @cost(weight: "10")
  methods("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [MethodSortInput!] @cost(weight: "10") where: MethodFilterInput @cost(weight: "10")): MethodsConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node @cost(weight: "10")
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]! @cost(weight: "10")
  openIdConnectApplications: [OpenIdConnectApplication!]! @cost(weight: "10")
  openIdConnectAuthorizations: [OpenIdConnectAuthorization!]! @cost(weight: "10")
  openIdConnectScopes: [OpenIdConnectScope!]! @cost(weight: "10")
  openIdConnectTokens: [OpenIdConnectToken!]! @cost(weight: "10")
  pendingDatabases("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [DatabaseSortInput!] @cost(weight: "10") where: DatabaseFilterInput @cost(weight: "10")): PendingDatabasesConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  pendingInstitutions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [InstitutionSortInput!] @cost(weight: "10") where: InstitutionFilterInput @cost(weight: "10")): PendingInstitutionsConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  user(uuid: Uuid!): User @cost(weight: "10")
  users("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [UserSortInput!] @cost(weight: "10")): UsersConnection @listSize(assumedSize: 2147483647, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
}

type RegisterUserError {
  code: RegisterUserErrorCode!
  message: String!
  path: [String!]!
}

type RegisterUserPayload {
  errors: [RegisterUserError!]
  query: Query!
  user: User
}

type RemoveComponentAssemblyError {
  code: RemoveComponentAssemblyErrorCode!
  message: String!
  path: [String!]!
}

type RemoveComponentAssemblyPayload {
  assembledComponent: Component @cost(weight: "10")
  errors: [RemoveComponentAssemblyError!]
  partComponent: Component @cost(weight: "10")
  query: Query!
}

type RemoveComponentGeneralizationError {
  code: RemoveComponentGeneralizationErrorCode!
  message: String!
  path: [String!]!
}

type RemoveComponentGeneralizationPayload {
  concreteComponent: Component @cost(weight: "10")
  errors: [RemoveComponentGeneralizationError!]
  generalComponent: Component @cost(weight: "10")
  query: Query!
}

type RemoveComponentManufacturerError {
  code: RemoveComponentManufacturerErrorCode!
  message: String!
  path: [String!]!
}

type RemoveComponentManufacturerPayload {
  component: Component @cost(weight: "10")
  errors: [RemoveComponentManufacturerError!]
  institution: Institution @cost(weight: "10")
  query: Query!
}

type RemoveComponentVariantError {
  code: RemoveComponentVariantErrorCode!
  message: String!
  path: [String!]!
}

type RemoveComponentVariantPayload {
  errors: [RemoveComponentVariantError!]
  oneComponent: Component @cost(weight: "10")
  otherComponent: Component @cost(weight: "10")
  query: Query!
}

type RemoveInstitutionMethodDeveloperError {
  code: RemoveInstitutionMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type RemoveInstitutionMethodDeveloperPayload {
  developedMethodEdge: InstitutionDevelopedMethodEdge
  errors: [RemoveInstitutionMethodDeveloperError!]
  methodDeveloperEdge: InstitutionMethodDeveloperEdge
  query: Query!
}

type RemoveInstitutionRepresentativeError {
  code: RemoveInstitutionRepresentativeErrorCode!
  message: String!
  path: [String!]!
}

type RemoveInstitutionRepresentativePayload {
  errors: [RemoveInstitutionRepresentativeError!]
  institution: Institution @cost(weight: "10")
  query: Query!
  user: User @cost(weight: "10")
}

type RemoveUserMethodDeveloperError {
  code: RemoveUserMethodDeveloperErrorCode!
  message: String!
  path: [String!]!
}

type RemoveUserMethodDeveloperPayload {
  developedMethodEdge: UserDevelopedMethodEdge
  errors: [RemoveUserMethodDeveloperError!]
  methodDeveloperEdge: UserMethodDeveloperEdge
  query: Query!
}

type RemoveUserRoleError {
  code: RemoveUserRoleErrorCode!
  message: String!
  path: [String!]!
}

type RemoveUserRolePayload {
  errors: [RemoveUserRoleError!]
  query: Query!
  user: User
}

type RequestUserPasswordResetError {
  code: RequestUserPasswordResetErrorCode!
  message: String!
  path: [String!]!
}

type RequestUserPasswordResetPayload {
  errors: [RequestUserPasswordResetError!]
  query: Query!
}

type ResendUserEmailConfirmationError {
  code: ResendUserEmailConfirmationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailConfirmationPayload {
  errors: [ResendUserEmailConfirmationError!]
  query: Query!
}

type ResendUserEmailVerificationError {
  code: ResendUserEmailVerificationErrorCode!
  message: String!
  path: [String!]!
}

type ResendUserEmailVerificationPayload {
  errors: [ResendUserEmailVerificationError!]
  query: Query!
  user: User
}

type ResetUserPasswordError {
  code: ResetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type ResetUserPasswordPayload {
  errors: [ResetUserPasswordError!]
  query: Query!
}

type ResetUserTwoFactorAuthenticatorError {
  code: ResetUserTwoFactorAuthenticatorErrorCode!
  message: String!
  path: [String!]!
}

type ResetUserTwoFactorAuthenticatorPayload {
  errors: [ResetUserTwoFactorAuthenticatorError!]
  query: Query!
  user: User
}

type ResponseApproval {
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  timestamp: DateTime!
}

type SetUserPasswordError {
  code: SetUserPasswordErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPasswordPayload {
  errors: [SetUserPasswordError!]
  query: Query!
  user: User
}

type SetUserPhoneNumberError {
  code: SetUserPhoneNumberErrorCode!
  message: String!
  path: [String!]!
}

type SetUserPhoneNumberPayload {
  errors: [SetUserPhoneNumberError!]
  query: Query!
  user: User
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
type Standard implements Reference {
  abstract: String
  locator: Url
  numeration: Numeration!
  "The section of the standard to which the reference refers to."
  section: String
  standardizers: [Standardizer!]!
  title: String
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: Int
}

type SwitchInstitutionOperatingStateError {
  code: SwitchInstitutionOperatingStateErrorCode!
  message: String!
  path: [String!]!
}

type SwitchInstitutionOperatingStatePayload {
  errors: [SwitchInstitutionOperatingStateError!]
  institution: Institution
  query: Query!
}

type ToTreeVertexAppliedConversionMethod {
  arguments: [NamedMethodArgument!]!
  method: Method @cost(weight: "10")
  methodId: Uuid!
  sourceName: String!
}

type TwoFactorAuthentication {
  hasAuthenticator: Boolean!
  isEnabled: Boolean!
  isMachineRemembered: Boolean!
  recoveryCodesLeftCount: Int!
}

type UpdateComponentAssemblyError {
  code: UpdateComponentAssemblyErrorCode!
  message: String!
  path: [String!]!
}

type UpdateComponentAssemblyPayload {
  assembledOfEdge: ComponentAssembledOfEdge
  errors: [UpdateComponentAssemblyError!]
  partOfEdge: ComponentPartOfEdge
  query: Query!
}

type UpdateComponentError {
  code: UpdateComponentErrorCode!
  message: String!
  path: [String!]!
}

type UpdateComponentPayload {
  component: Component
  errors: [UpdateComponentError!]
  query: Query!
}

type UpdateDataFormatError {
  code: UpdateDataFormatErrorCode!
  message: String!
  path: [String!]!
}

type UpdateDataFormatPayload {
  dataFormat: DataFormat
  errors: [UpdateDataFormatError!]
  query: Query!
}

type UpdateDatabaseError {
  code: UpdateDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type UpdateDatabasePayload {
  database: Database
  errors: [UpdateDatabaseError!]
  query: Query!
}

type UpdateInstitutionError {
  code: UpdateInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type UpdateInstitutionPayload {
  errors: [UpdateInstitutionError!]
  institution: Institution
  query: Query!
}

type UpdateMethodError {
  code: UpdateMethodErrorCode!
  message: String!
  path: [String!]!
}

type UpdateMethodPayload {
  errors: [UpdateMethodError!]
  method: Method
  query: Query!
}

type User implements Node & Stakeholder {
  canCurrentUserDeleteUser: Boolean! @cost(weight: "10")
  developedMethods(pending: Boolean! = false): UserDevelopedMethodConnection! @cost(weight: "10")
  email: String @cost(weight: "10")
  hasPassword: Boolean @cost(weight: "10")
  id: ID!
  isEmailConfirmed: Boolean @cost(weight: "10")
  isPhoneNumberConfirmed: Boolean @cost(weight: "10")
  "Full name"
  name: String! @cost(weight: "10")
  phoneNumber: String @cost(weight: "10")
  postalAddress: String @cost(weight: "10")
  representedInstitutions(pending: Boolean! = false): UserRepresentedInstitutionConnection! @cost(weight: "10")
  roles: [UserRole!] @cost(weight: "10")
  rolesCurrentUserCanAdd: [UserRole!]! @cost(weight: "10")
  rolesCurrentUserCanRemove: [UserRole!]! @cost(weight: "10")
  twoFactorAuthentication: TwoFactorAuthentication @cost(weight: "10")
  uuid: Uuid! @cost(weight: "10")
  websiteLocator: Url @cost(weight: "10")
}

type UserDevelopedMethodConnection {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  edges: [UserDevelopedMethodEdge!]! @cost(weight: "10")
}

type UserDevelopedMethodEdge {
  node: Method! @cost(weight: "10")
}

type UserMethodDeveloperEdge {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  canCurrentUserRemoveEdge: Boolean! @cost(weight: "10")
  node: User! @cost(weight: "10")
}

type UserRepresentedInstitutionConnection {
  canCurrentUserConfirmEdge: Boolean! @cost(weight: "10")
  edges: [UserRepresentedInstitutionEdge!]! @cost(weight: "10")
}

type UserRepresentedInstitutionEdge {
  node: Institution! @cost(weight: "10")
  role: InstitutionRepresentativeRole!
}

"A connection to a list of items."
type UsersConnection {
  "A list of edges."
  edges: [UsersEdge!]
  "A flattened list of the nodes."
  nodes: [User!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type UsersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User!
}

type VerifyDatabaseError {
  code: VerifyDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type VerifyDatabasePayload {
  database: Database
  errors: [VerifyDatabaseError!]
  query: Query!
}

type VerifyInstitutionError {
  code: VerifyInstitutionErrorCode!
  message: String!
  path: [String!]!
}

type VerifyInstitutionPayload {
  errors: [VerifyInstitutionError!]
  institution: Institution
  query: Query!
}

input AddComponentAssemblyInput {
  assembledComponentId: Uuid!
  index: Byte
  partComponentId: Uuid!
  primeSurface: PrimeSurface
}

input AddComponentGeneralizationInput {
  concreteComponentId: Uuid!
  generalComponentId: Uuid!
}

input AddComponentManufacturerInput {
  componentId: Uuid!
  institutionId: Uuid!
}

input AddComponentVariantInput {
  oneComponentId: Uuid!
  otherComponentId: Uuid!
}

input AddInstitutionMethodDeveloperInput {
  institutionId: Uuid!
  methodId: Uuid!
}

input AddInstitutionRepresentativeInput {
  institutionId: Uuid!
  role: InstitutionRepresentativeRole!
  userId: Uuid!
}

input AddUserMethodDeveloperInput {
  methodId: Uuid!
  userId: Uuid!
}

input AddUserRoleInput {
  role: UserRole!
  userId: Uuid!
}

input BooleanOperationFilterInput {
  eq: Boolean @cost(weight: "10")
  neq: Boolean @cost(weight: "10")
}

input ByteOperationFilterInput {
  eq: Byte @cost(weight: "10")
  neq: Byte @cost(weight: "10")
  in: [Byte] @cost(weight: "10")
  nin: [Byte] @cost(weight: "10")
  gt: Byte @cost(weight: "10")
  ngt: Byte @cost(weight: "10")
  gte: Byte @cost(weight: "10")
  ngte: Byte @cost(weight: "10")
  lt: Byte @cost(weight: "10")
  nlt: Byte @cost(weight: "10")
  lte: Byte @cost(weight: "10")
  nlte: Byte @cost(weight: "10")
}

input CalorimetricDataPropositionInput {
  and: [CalorimetricDataPropositionInput!]
  componentId: UuidPropositionInput
  gValues: FloatsPropositionInput
  not: CalorimetricDataPropositionInput
  or: [CalorimetricDataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
  uValues: FloatsPropositionInput
}

input ChangeInstitutionRepresentativeRoleInput {
  institutionId: Uuid!
  role: InstitutionRepresentativeRole!
  userId: Uuid!
}

input ChangeUserEmailInput {
  newEmail: String!
}

input ChangeUserPasswordInput {
  currentPassword: String!
  newPassword: String!
  newPasswordConfirmation: String!
}

input CielabColorPropositionInput {
  aStar: FloatPropositionInput
  bStar: FloatPropositionInput
  lStar: FloatPropositionInput
}

input CielabColorsPropositionInput {
  all: CielabColorPropositionInput
  none: CielabColorPropositionInput
  some: CielabColorPropositionInput
}

input ClosedIntervalInput {
  lowerBound: Float!
  upperBound: Float!
}

input ComponentAssemblyFilterInput {
  and: [ComponentAssemblyFilterInput!]
  or: [ComponentAssemblyFilterInput!]
  assembledComponent: ComponentFilterInput
  partComponent: ComponentFilterInput
  index: ByteOperationFilterInput
  primeSurface: NullableOfPrimeSurfaceOperationFilterInput
}

input ComponentCategoryOperationFilterInput {
  eq: ComponentCategory @cost(weight: "10")
  neq: ComponentCategory @cost(weight: "10")
  in: [ComponentCategory!] @cost(weight: "10")
  nin: [ComponentCategory!] @cost(weight: "10")
}

input ComponentFilterInput {
  and: [ComponentFilterInput!]
  or: [ComponentFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  abbreviation: StringOperationFilterInput
  description: StringOperationFilterInput
  categories: ListComponentCategoryOperationFilterInput
  partOf: ListComponentFilterTypeFilterInput
  parts: ListComponentFilterTypeFilterInput
  partOfEdges: ListComponentAssemblyFilterTypeFilterInput
  partEdges: ListComponentAssemblyFilterTypeFilterInput
  concretizations: ListComponentFilterTypeFilterInput
  generalizations: ListComponentFilterTypeFilterInput
  variants: ListComponentFilterTypeFilterInput
  manufacturers: ListInstitutionFilterTypeFilterInput
  manufacturerEdges: ListComponentManufacturerFilterTypeFilterInput
}

input ComponentManufacturerFilterInput {
  and: [ComponentManufacturerFilterInput!]
  or: [ComponentManufacturerFilterInput!]
  component: ComponentFilterInput
  institution: InstitutionFilterInput
  pending: BooleanOperationFilterInput
}

input ComponentSortInput {
  name: SortEnumType @cost(weight: "10")
  abbreviation: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  availability: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
}

input ConfirmComponentManufacturerInput {
  componentId: Uuid!
  institutionId: Uuid!
}

input ConfirmInstitutionMethodDeveloperInput {
  institutionId: Uuid!
  methodId: Uuid!
}

input ConfirmInstitutionRepresentativeInput {
  institutionId: Uuid!
  userId: Uuid!
}

input ConfirmUserEmailChangeInput {
  confirmationCode: String!
  currentEmail: String!
  newEmail: String!
}

input ConfirmUserEmailInput {
  confirmationCode: String!
  email: String!
}

input ConfirmUserMethodDeveloperInput {
  methodId: Uuid!
  userId: Uuid!
}

input CreateComponentInput {
  abbreviation: String
  availability: OpenEndedDateTimeRangeInput
  categories: [ComponentCategory!]!
  description: String!
  manufacturerId: Uuid!
  name: String!
}

input CreateDataFormatInput {
  description: String!
  extension: String
  managerId: Uuid!
  mediaType: String!
  name: String!
  publication: CreatePublicationInput
  schemaLocator: Url
  standard: CreateStandardInput
}

input CreateDatabaseInput {
  description: String!
  locator: Url!
  name: String!
  operatorId: Uuid!
}

input CreateInstitutionInput {
  abbreviation: String
  description: String!
  managerId: Uuid
  name: String!
  ownerIds: [Uuid!]!
  publicKey: String
  websiteLocator: Url
}

input CreateMethodInput {
  availability: OpenEndedDateTimeRangeInput
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  institutionDeveloperIds: [Uuid!]!
  managerId: Uuid!
  name: String!
  publication: CreatePublicationInput
  standard: CreateStandardInput
  userDeveloperIds: [Uuid!]!
  validity: OpenEndedDateTimeRangeInput
}

input CreateNumerationInput {
  mainNumber: String!
  prefix: String
  suffix: String
}

input CreatePublicationInput {
  abstract: String
  arXiv: String
  authors: [String!]
  doi: String
  section: String
  title: String
  urn: String
  webAddress: Url
}

input CreateStandardInput {
  abstract: String
  locator: Url
  numeration: CreateNumerationInput!
  section: String
  standardizers: [Standardizer!]!
  title: String
  year: Int
}

input DataFormatFilterInput {
  and: [DataFormatFilterInput!]
  or: [DataFormatFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  extension: StringOperationFilterInput
  description: StringOperationFilterInput
  mediaType: StringOperationFilterInput
  schemaLocator: UrlOperationFilterInput
  standard: StandardFilterInput
  publication: PublicationFilterInput
  manager: InstitutionFilterInput
}

input DataFormatSortInput {
  name: SortEnumType @cost(weight: "10")
  extension: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  mediaType: SortEnumType @cost(weight: "10")
  schemaLocator: UriSortInput @cost(weight: "10")
  standard: StandardSortInput @cost(weight: "10")
  publication: PublicationSortInput @cost(weight: "10")
  reference: IReferenceSortInput @cost(weight: "10")
  managerId: SortEnumType @cost(weight: "10")
  manager: InstitutionSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
}

input DataPropositionInput {
  and: [DataPropositionInput!]
  cielabColors: CielabColorsPropositionInput
  colorRenderingIndices: FloatsPropositionInput
  componentId: UuidPropositionInput
  gValues: FloatsPropositionInput
  infraredEmittances: FloatsPropositionInput
  nearnormalHemisphericalSolarReflectances: FloatsPropositionInput
  nearnormalHemisphericalSolarTransmittances: FloatsPropositionInput
  nearnormalHemisphericalVisibleReflectances: FloatsPropositionInput
  nearnormalHemisphericalVisibleTransmittances: FloatsPropositionInput
  not: DataPropositionInput
  or: [DataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
  uValues: FloatsPropositionInput
}

input DatabaseFilterInput {
  and: [DatabaseFilterInput!]
  or: [DatabaseFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  locator: UrlOperationFilterInput
  operator: InstitutionFilterInput
}

input DatabaseSortInput {
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  locator: UriSortInput @cost(weight: "10")
  verificationState: SortEnumType @cost(weight: "10")
  verificationCode: SortEnumType @cost(weight: "10")
  operatorId: SortEnumType @cost(weight: "10")
  operator: InstitutionSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
}

input DeleteInstitutionInput {
  institutionId: Uuid!
}

input DeletePersonalUserDataInput {
  password: String
}

input DeleteUserInput {
  userId: Uuid!
}

input EnableUserTwoFactorAuthenticatorInput {
  verificationCode: String!
}

input FileMetaInformationPropositionInput {
  dataFormatId: UuidPropositionInput
}

input FilesMetaInformationPropositionInput {
  all: FileMetaInformationPropositionInput
  none: FileMetaInformationPropositionInput
  some: FileMetaInformationPropositionInput
}

input FloatPropositionInput {
  equalTo: Float
  greaterThanOrEqualTo: Float
  inClosedInterval: ClosedIntervalInput
  lessThanOrEqualTo: Float
}

input FloatsPropositionInput {
  all: FloatPropositionInput
  none: FloatPropositionInput
  some: FloatPropositionInput
}

input GeometricDataPropositionInput {
  and: [GeometricDataPropositionInput!]
  componentId: UuidPropositionInput
  not: GeometricDataPropositionInput
  or: [GeometricDataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
  thicknesses: FloatsPropositionInput
}

input GetHttpsResourcePropositionInput {
  archivedFilesMetaInformation: FilesMetaInformationPropositionInput
  dataFormatId: UuidPropositionInput
}

input GetHttpsResourcesPropositionInput {
  all: GetHttpsResourcePropositionInput
  none: GetHttpsResourcePropositionInput
  some: GetHttpsResourcePropositionInput
}

input HygrothermalDataPropositionInput {
  and: [HygrothermalDataPropositionInput!]
  componentId: UuidPropositionInput
  not: HygrothermalDataPropositionInput
  or: [HygrothermalDataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
}

input IReferenceSortInput {
  title: SortEnumType @cost(weight: "10")
  abstract: SortEnumType @cost(weight: "10")
  section: SortEnumType @cost(weight: "10")
}

input InstitutionFilterInput {
  and: [InstitutionFilterInput!]
  or: [InstitutionFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  abbreviation: StringOperationFilterInput
  description: StringOperationFilterInput
  websiteLocator: UrlOperationFilterInput
  state: InstitutionStateOperationFilterInput
  developedMethods: ListMethodFilterTypeFilterInput
  developedMethodEdges: ListInstitutionMethodDeveloperFilterTypeFilterInput
  managedMethods: ListMethodFilterTypeFilterInput
  managedDataFormats: ListDataFormatFilterTypeFilterInput
  manufacturedComponents: ListComponentFilterTypeFilterInput
  manufacturedComponentEdges: ListComponentManufacturerFilterTypeFilterInput
  operatedDatabases: ListDatabaseFilterTypeFilterInput
  manager: InstitutionFilterInput
  managedInstitutions: ListInstitutionFilterTypeFilterInput
  representatives: ListUserFilterTypeFilterInput
  representativeEdges: ListInstitutionRepresentativeFilterTypeFilterInput
}

input InstitutionMethodDeveloperFilterInput {
  and: [InstitutionMethodDeveloperFilterInput!]
  or: [InstitutionMethodDeveloperFilterInput!]
  method: MethodFilterInput
  institution: InstitutionFilterInput
  pending: BooleanOperationFilterInput
}

input InstitutionRepresentativeFilterInput {
  and: [InstitutionRepresentativeFilterInput!]
  or: [InstitutionRepresentativeFilterInput!]
  institution: InstitutionFilterInput
  user: UserFilterInput
  role: InstitutionRepresentativeRoleOperationFilterInput
  pending: BooleanOperationFilterInput
}

input InstitutionRepresentativeRoleOperationFilterInput {
  eq: InstitutionRepresentativeRole @cost(weight: "10")
  neq: InstitutionRepresentativeRole @cost(weight: "10")
  in: [InstitutionRepresentativeRole!] @cost(weight: "10")
  nin: [InstitutionRepresentativeRole!] @cost(weight: "10")
}

input InstitutionSortInput {
  abbreviation: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  websiteLocator: UriSortInput @cost(weight: "10")
  publicKey: SortEnumType @cost(weight: "10")
  state: SortEnumType @cost(weight: "10")
  operatingState: SortEnumType @cost(weight: "10")
  managerId: SortEnumType @cost(weight: "10")
  manager: InstitutionSortInput @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
}

input InstitutionStateOperationFilterInput {
  eq: InstitutionState @cost(weight: "10")
  neq: InstitutionState @cost(weight: "10")
  in: [InstitutionState!] @cost(weight: "10")
  nin: [InstitutionState!] @cost(weight: "10")
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input ListComponentAssemblyFilterTypeFilterInput {
  all: ComponentAssemblyFilterInput @cost(weight: "10")
  none: ComponentAssemblyFilterInput @cost(weight: "10")
  some: ComponentAssemblyFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListComponentCategoryOperationFilterInput {
  all: ComponentCategoryOperationFilterInput @cost(weight: "10")
  none: ComponentCategoryOperationFilterInput @cost(weight: "10")
  some: ComponentCategoryOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListComponentFilterTypeFilterInput {
  all: ComponentFilterInput @cost(weight: "10")
  none: ComponentFilterInput @cost(weight: "10")
  some: ComponentFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListComponentManufacturerFilterTypeFilterInput {
  all: ComponentManufacturerFilterInput @cost(weight: "10")
  none: ComponentManufacturerFilterInput @cost(weight: "10")
  some: ComponentManufacturerFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListDataFormatFilterTypeFilterInput {
  all: DataFormatFilterInput @cost(weight: "10")
  none: DataFormatFilterInput @cost(weight: "10")
  some: DataFormatFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListDatabaseFilterTypeFilterInput {
  all: DatabaseFilterInput @cost(weight: "10")
  none: DatabaseFilterInput @cost(weight: "10")
  some: DatabaseFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListInstitutionFilterTypeFilterInput {
  all: InstitutionFilterInput @cost(weight: "10")
  none: InstitutionFilterInput @cost(weight: "10")
  some: InstitutionFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListInstitutionMethodDeveloperFilterTypeFilterInput {
  all: InstitutionMethodDeveloperFilterInput @cost(weight: "10")
  none: InstitutionMethodDeveloperFilterInput @cost(weight: "10")
  some: InstitutionMethodDeveloperFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListInstitutionRepresentativeFilterTypeFilterInput {
  all: InstitutionRepresentativeFilterInput @cost(weight: "10")
  none: InstitutionRepresentativeFilterInput @cost(weight: "10")
  some: InstitutionRepresentativeFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListMethodCategoryOperationFilterInput {
  all: MethodCategoryOperationFilterInput @cost(weight: "10")
  none: MethodCategoryOperationFilterInput @cost(weight: "10")
  some: MethodCategoryOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListMethodFilterTypeFilterInput {
  all: MethodFilterInput @cost(weight: "10")
  none: MethodFilterInput @cost(weight: "10")
  some: MethodFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListStandardizerOperationFilterInput {
  all: StandardizerOperationFilterInput @cost(weight: "10")
  none: StandardizerOperationFilterInput @cost(weight: "10")
  some: StandardizerOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput @cost(weight: "10")
  none: StringOperationFilterInput @cost(weight: "10")
  some: StringOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListUserFilterTypeFilterInput {
  all: UserFilterInput @cost(weight: "10")
  none: UserFilterInput @cost(weight: "10")
  some: UserFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListUserMethodDeveloperFilterTypeFilterInput {
  all: UserMethodDeveloperFilterInput @cost(weight: "10")
  none: UserMethodDeveloperFilterInput @cost(weight: "10")
  some: UserMethodDeveloperFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input LoginUserInput {
  email: String!
  password: String!
}

input LoginUserWithRecoveryCodeInput {
  recoveryCode: String!
}

input LoginUserWithTwoFactorCodeInput {
  authenticatorCode: String!
  rememberMachine: Boolean!
}

input MethodCategoryOperationFilterInput {
  eq: MethodCategory @cost(weight: "10")
  neq: MethodCategory @cost(weight: "10")
  in: [MethodCategory!] @cost(weight: "10")
  nin: [MethodCategory!] @cost(weight: "10")
}

input MethodFilterInput {
  and: [MethodFilterInput!]
  or: [MethodFilterInput!]
  id: UuidOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  standard: StandardFilterInput
  publication: PublicationFilterInput
  calculationLocator: UrlOperationFilterInput
  categories: ListMethodCategoryOperationFilterInput
  institutionDevelopers: ListInstitutionFilterTypeFilterInput
  institutionDeveloperEdges: ListInstitutionMethodDeveloperFilterTypeFilterInput
  userDevelopers: ListUserFilterTypeFilterInput
  userDeveloperEdges: ListUserMethodDeveloperFilterTypeFilterInput
  manager: InstitutionFilterInput
}

input MethodSortInput {
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  standard: StandardSortInput @cost(weight: "10")
  publication: PublicationSortInput @cost(weight: "10")
  reference: IReferenceSortInput @cost(weight: "10")
  validity: SortEnumType @cost(weight: "10")
  availability: SortEnumType @cost(weight: "10")
  calculationLocator: UriSortInput @cost(weight: "10")
  managerId: SortEnumType @cost(weight: "10")
  manager: InstitutionSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
}

input NullableOfPrimeSurfaceOperationFilterInput {
  eq: PrimeSurface @cost(weight: "10")
  neq: PrimeSurface @cost(weight: "10")
  in: [PrimeSurface] @cost(weight: "10")
  nin: [PrimeSurface] @cost(weight: "10")
}

input NumerationFilterInput {
  and: [NumerationFilterInput!]
  or: [NumerationFilterInput!]
  prefix: StringOperationFilterInput
  mainNumber: StringOperationFilterInput
  suffix: StringOperationFilterInput
}

input NumerationSortInput {
  prefix: SortEnumType @cost(weight: "10")
  mainNumber: SortEnumType @cost(weight: "10")
  suffix: SortEnumType @cost(weight: "10")
}

input OpenEndedDateTimeRangeInput {
  from: DateTime
  to: DateTime
}

input OpticalDataPropositionInput {
  and: [OpticalDataPropositionInput!]
  cielabColors: CielabColorsPropositionInput
  colorRenderingIndices: FloatsPropositionInput
  componentId: UuidPropositionInput
  infraredEmittances: FloatsPropositionInput
  nearnormalHemisphericalSolarReflectances: FloatsPropositionInput
  nearnormalHemisphericalSolarTransmittances: FloatsPropositionInput
  nearnormalHemisphericalVisibleReflectances: FloatsPropositionInput
  nearnormalHemisphericalVisibleTransmittances: FloatsPropositionInput
  not: OpticalDataPropositionInput
  or: [OpticalDataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
}

input PhotovoltaicDataPropositionInput {
  and: [PhotovoltaicDataPropositionInput!]
  componentId: UuidPropositionInput
  not: PhotovoltaicDataPropositionInput
  or: [PhotovoltaicDataPropositionInput!]
  resources: GetHttpsResourcesPropositionInput
}

input PublicationFilterInput {
  and: [PublicationFilterInput!]
  or: [PublicationFilterInput!]
  authors: ListStringOperationFilterInput
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: StringOperationFilterInput
  "The website arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: StringOperationFilterInput
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: StringOperationFilterInput
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: UrlOperationFilterInput
  title: StringOperationFilterInput
  abstract: StringOperationFilterInput
  "Referenced section"
  section: StringOperationFilterInput
}

input PublicationSortInput {
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: SortEnumType @cost(weight: "10")
  "The website arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: SortEnumType @cost(weight: "10")
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: SortEnumType @cost(weight: "10")
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: UriSortInput @cost(weight: "10")
  title: SortEnumType @cost(weight: "10")
  abstract: SortEnumType @cost(weight: "10")
  "Referenced section"
  section: SortEnumType @cost(weight: "10")
}

input RegisterUserInput {
  email: String!
  name: String!
  password: String!
  passwordConfirmation: String!
  returnTo: Url
}

input RemoveComponentAssemblyInput {
  assembledComponentId: Uuid!
  partComponentId: Uuid!
}

input RemoveComponentGeneralizationInput {
  concreteComponentId: Uuid!
  generalComponentId: Uuid!
}

input RemoveComponentManufacturerInput {
  componentId: Uuid!
  institutionId: Uuid!
}

input RemoveComponentVariantInput {
  oneComponentId: Uuid!
  otherComponentId: Uuid!
}

input RemoveInstitutionMethodDeveloperInput {
  institutionId: Uuid!
  methodId: Uuid!
}

input RemoveInstitutionRepresentativeInput {
  institutionId: Uuid!
  userId: Uuid!
}

input RemoveUserMethodDeveloperInput {
  methodId: Uuid!
  userId: Uuid!
}

input RemoveUserRoleInput {
  role: UserRole!
  userId: Uuid!
}

input RequestUserPasswordResetInput {
  email: String!
  returnTo: Url
}

input ResendUserEmailConfirmationInput {
  email: String!
}

input ResetUserPasswordInput {
  email: String!
  password: String!
  passwordConfirmation: String!
  resetCode: String!
}

input SetUserPasswordInput {
  password: String!
  passwordConfirmation: String!
}

input SetUserPhoneNumberInput {
  phoneNumber: String!
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
input StandardFilterInput {
  and: [StandardFilterInput!]
  or: [StandardFilterInput!]
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: IntOperationFilterInput
  numeration: NumerationFilterInput
  standardizers: ListStandardizerOperationFilterInput
  locator: UrlOperationFilterInput
  title: StringOperationFilterInput
  abstract: StringOperationFilterInput
  "The section of the standard to which the reference refers to."
  section: StringOperationFilterInput
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
input StandardSortInput {
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: SortEnumType @cost(weight: "10")
  numeration: NumerationSortInput @cost(weight: "10")
  locator: UriSortInput @cost(weight: "10")
  title: SortEnumType @cost(weight: "10")
  abstract: SortEnumType @cost(weight: "10")
  "The section of the standard to which the reference refers to."
  section: SortEnumType @cost(weight: "10")
}

input StandardizerOperationFilterInput {
  eq: Standardizer @cost(weight: "10")
  neq: Standardizer @cost(weight: "10")
  in: [Standardizer!] @cost(weight: "10")
  nin: [Standardizer!] @cost(weight: "10")
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

input SwitchInstitutionOperatingStateInput {
  institutionId: Uuid!
}

input UpdateComponentAssemblyInput {
  assembledComponentId: Uuid!
  index: Byte
  partComponentId: Uuid!
  primeSurface: PrimeSurface
}

input UpdateComponentInput {
  abbreviation: String
  availability: OpenEndedDateTimeRangeInput
  categories: [ComponentCategory!]!
  componentId: Uuid!
  description: String!
  name: String!
}

input UpdateDataFormatInput {
  dataFormatId: Uuid!
  description: String!
  extension: String
  mediaType: String!
  name: String!
  publication: UpdatePublicationInput
  schemaLocator: Url
  standard: UpdateStandardInput
}

input UpdateDatabaseInput {
  databaseId: Uuid!
  description: String!
  locator: Url!
  name: String!
}

input UpdateInstitutionInput {
  abbreviation: String
  description: String!
  institutionId: Uuid!
  name: String!
  publicKey: String
  websiteLocator: Url
}

input UpdateMethodInput {
  availability: OpenEndedDateTimeRangeInput
  calculationLocator: Url
  categories: [MethodCategory!]!
  description: String!
  methodId: Uuid!
  name: String!
  publication: UpdatePublicationInput
  standard: UpdateStandardInput
  validity: OpenEndedDateTimeRangeInput
}

input UpdateNumerationInput {
  mainNumber: String!
  prefix: String
  suffix: String
}

input UpdatePublicationInput {
  abstract: String
  arXiv: String
  authors: [String!]
  doi: String
  section: String
  title: String
  urn: String
  webAddress: Url
}

input UpdateStandardInput {
  abstract: String
  locator: Url
  numeration: UpdateNumerationInput!
  section: String
  standardizers: [Standardizer!]!
  title: String
  year: Int
}

input UriSortInput {
  absolutePath: SortEnumType @cost(weight: "10")
  absoluteUri: SortEnumType @cost(weight: "10")
  localPath: SortEnumType @cost(weight: "10")
  authority: SortEnumType @cost(weight: "10")
  hostNameType: SortEnumType @cost(weight: "10")
  isDefaultPort: SortEnumType @cost(weight: "10")
  isFile: SortEnumType @cost(weight: "10")
  isLoopback: SortEnumType @cost(weight: "10")
  pathAndQuery: SortEnumType @cost(weight: "10")
  isUnc: SortEnumType @cost(weight: "10")
  host: SortEnumType @cost(weight: "10")
  port: SortEnumType @cost(weight: "10")
  query: SortEnumType @cost(weight: "10")
  fragment: SortEnumType @cost(weight: "10")
  scheme: SortEnumType @cost(weight: "10")
  originalString: SortEnumType @cost(weight: "10")
  dnsSafeHost: SortEnumType @cost(weight: "10")
  idnHost: SortEnumType @cost(weight: "10")
  isAbsoluteUri: SortEnumType @cost(weight: "10")
  userEscaped: SortEnumType @cost(weight: "10")
  userInfo: SortEnumType @cost(weight: "10")
}

input UrlOperationFilterInput {
  eq: Url @cost(weight: "10")
  neq: Url @cost(weight: "10")
  in: [Url] @cost(weight: "10")
  nin: [Url] @cost(weight: "10")
  gt: Url @cost(weight: "10")
  ngt: Url @cost(weight: "10")
  gte: Url @cost(weight: "10")
  ngte: Url @cost(weight: "10")
  lt: Url @cost(weight: "10")
  nlt: Url @cost(weight: "10")
  lte: Url @cost(weight: "10")
  nlte: Url @cost(weight: "10")
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  id: UuidOperationFilterInput
  developedMethods: ListMethodFilterTypeFilterInput
  developedMethodEdges: ListUserMethodDeveloperFilterTypeFilterInput
  representedInstitutions: ListInstitutionFilterTypeFilterInput
  representedInstitutionEdges: ListInstitutionRepresentativeFilterTypeFilterInput
}

input UserMethodDeveloperFilterInput {
  and: [UserMethodDeveloperFilterInput!]
  or: [UserMethodDeveloperFilterInput!]
  method: MethodFilterInput
  user: UserFilterInput
  pending: BooleanOperationFilterInput
}

input UserSortInput {
  postalAddress: SortEnumType @cost(weight: "10")
  websiteLocator: UriSortInput @cost(weight: "10")
  version: SortEnumType @cost(weight: "10")
  "Full name"
  name: SortEnumType @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
  userName: SortEnumType @cost(weight: "10")
  normalizedUserName: SortEnumType @cost(weight: "10")
  email: SortEnumType @cost(weight: "10")
  normalizedEmail: SortEnumType @cost(weight: "10")
  emailConfirmed: SortEnumType @cost(weight: "10")
  passwordHash: SortEnumType @cost(weight: "10")
  securityStamp: SortEnumType @cost(weight: "10")
  concurrencyStamp: SortEnumType @cost(weight: "10")
  phoneNumber: SortEnumType @cost(weight: "10")
  phoneNumberConfirmed: SortEnumType @cost(weight: "10")
  twoFactorEnabled: SortEnumType @cost(weight: "10")
  lockoutEnd: SortEnumType @cost(weight: "10")
  lockoutEnabled: SortEnumType @cost(weight: "10")
  accessFailedCount: SortEnumType @cost(weight: "10")
}

input UuidOperationFilterInput {
  eq: Uuid @cost(weight: "10")
  neq: Uuid @cost(weight: "10")
  in: [Uuid] @cost(weight: "10")
  nin: [Uuid] @cost(weight: "10")
  gt: Uuid @cost(weight: "10")
  ngt: Uuid @cost(weight: "10")
  gte: Uuid @cost(weight: "10")
  ngte: Uuid @cost(weight: "10")
  lt: Uuid @cost(weight: "10")
  nlt: Uuid @cost(weight: "10")
  lte: Uuid @cost(weight: "10")
  nlte: Uuid @cost(weight: "10")
}

input UuidPropositionInput {
  equalTo: Uuid
}

input VerifyDatabaseInput {
  databaseId: Uuid!
}

input VerifyInstitutionInput {
  institutionId: Uuid!
}

enum AddComponentAssemblyErrorCode {
  UNKNOWN
  UNKNOWN_ASSEMBLED_COMPONENT
  UNKNOWN_PART_COMPONENT
  DUPLICATE
  UNAUTHORIZED
}

enum AddComponentGeneralizationErrorCode {
  UNKNOWN
  UNKNOWN_GENERAL_COMPONENT
  UNKNOWN_CONCRETE_COMPONENT
  DUPLICATE
  UNAUTHORIZED
}

enum AddComponentManufacturerErrorCode {
  UNKNOWN
  UNKNOWN_COMPONENT
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  DUPLICATE
}

enum AddComponentVariantErrorCode {
  UNKNOWN
  UNKNOWN_ONE_COMPONENT
  UNKNOWN_OTHER_COMPONENT
  DUPLICATE
  UNAUTHORIZED
}

enum AddInstitutionMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  DUPLICATE
}

enum AddInstitutionRepresentativeErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  DUPLICATE
  UNAUTHORIZED
}

enum AddUserMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_USER
  UNAUTHORIZED
  DUPLICATE
}

enum AddUserRoleErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum ChangeInstitutionRepresentativeRoleErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_REPRESENTATIVE
  LAST_OWNER
}

enum ChangeUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_EMAIL
  UNKNOWN_CURRENT_EMAIL
}

enum ChangeUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NO_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum ComponentCategory {
  MATERIAL
  LAYER
  UNIT
}

enum ConfirmComponentManufacturerErrorCode {
  UNKNOWN
  UNKNOWN_COMPONENT
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_MANUFACTURER
}

enum ConfirmInstitutionMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum ConfirmInstitutionRepresentativeErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_REPRESENTATIVE
}

enum ConfirmUserEmailChangeErrorCode {
  UNKNOWN
  DUPLICATE_EMAIL
  INVALID_CONFIRMATION_CODE
  UNKNOWN_USER
}

enum ConfirmUserEmailErrorCode {
  UNKNOWN
  UNKNOWN_USER
  INVALID_CONFIRMATION_CODE
}

enum ConfirmUserMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum CreateComponentErrorCode {
  UNKNOWN
  UNKNOWN_MANUFACTURER
  UNAUTHORIZED
}

enum CreateDataFormatErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNKNOWN_MANAGER
  UNAUTHORIZED
}

enum CreateDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_OPERATOR
}

enum CreateInstitutionErrorCode {
  UNKNOWN
  NEITHER_OWNER_NOR_MANAGER
  UNKNOWN_OWNERS
  UNKNOWN_MANAGER
  UNAUTHORIZED
}

enum CreateMethodErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNKNOWN_MANAGER
  UNKNOWN_INSTITUTION_DEVELOPERS
  UNKNOWN_USER_DEVELOPERS
  UNAUTHORIZED
}

enum DataKind {
  CALORIMETRIC_DATA
  HYGROTHERMAL_DATA
  OPTICAL_DATA
  PHOTOVOLTAIC_DATA
  GEOMETRIC_DATA
}

enum DatabaseVerificationState {
  PENDING
  VERIFIED
}

enum DeleteInstitutionErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  MANAGING
}

enum DeletePersonalUserDataErrorCode {
  UNKNOWN
  UNKNOWN_USER
  MISSING_PASSWORD
  INCORRECT_PASSWORD
}

enum DeleteUserErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

enum DisableUserTwoFactorAuthenticationErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum EnableUserTwoFactorAuthenticatorErrorCode {
  UNKNOWN
  UNKNOWN_USER
  ENABLING_FAILED
  INVALID_VERIFICATION_CODE
}

enum ForgetUserTwoFactorAuthenticationClientErrorCode {
  UNKNOWN
  UNKNOWN_USER
}

enum GenerateUserTwoFactorAuthenticatorSharedKeyAndQrCodeUriErrorCode {
  UNKNOWN
  UNKNOWN_USER
  RESETTING_AUTHENTICATOR_KEY_FAILED
  GETTING_AUTHENTICATOR_KEY_FAILED
  GETTING_EMAIL_FAILED
}

enum GenerateUserTwoFactorRecoveryCodesErrorCode {
  UNKNOWN
  UNKNOWN_USER
  TWO_FACTOR_AUTHENTICATION_DISABLED
  CODE_GENERATION_FAILED
}

enum InstitutionOperatingState {
  OPERATING
  NOT_OPERATING
}

enum InstitutionRepresentativeRole {
  OWNER
  ASSISTANT
}

enum InstitutionState {
  PENDING
  VERIFIED
}

enum LoginUserErrorCode {
  INVALID
  LOCKED_OUT
  NOT_ALLOWED
  UNKNOWN
}

enum LoginUserWithRecoveryCodeErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NOT_ALLOWED
  LOCKED_OUT
  INVALID_RECOVERY_CODE
}

enum LoginUserWithTwoFactorCodeErrorCode {
  UNKNOWN
  UNKNOWN_USER
  NOT_ALLOWED
  LOCKED_OUT
  INVALID_AUTHENTICATOR_CODE
}

enum LogoutUserErrorCode {
  UNKNOWN
}

enum MethodCategory {
  MEASUREMENT
  CALCULATION
}

enum PrimeSurface {
  INSIDE
  OUTSIDE
}

enum RegisterUserErrorCode {
  UNKNOWN
  PASSWORD_CONFIRMATION_MISMATCH
  DUPLICATE_EMAIL
  INVALID_EMAIL
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
  NULL_OR_EMPTY_EMAIL
}

enum RemoveComponentAssemblyErrorCode {
  UNKNOWN
  UNKNOWN_ASSEMBLED_COMPONENT
  UNKNOWN_PART_COMPONENT
  UNKNOWN_ASSEMBLY
  UNAUTHORIZED
}

enum RemoveComponentGeneralizationErrorCode {
  UNKNOWN
  UNKNOWN_GENERAL_COMPONENT
  UNKNOWN_CONCRETE_COMPONENT
  UNKNOWN_GENERALIZATION
  UNAUTHORIZED
}

enum RemoveComponentManufacturerErrorCode {
  UNKNOWN
  UNKNOWN_COMPONENT
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_MANUFACTURER
  LAST_MANUFACTURER
}

enum RemoveComponentVariantErrorCode {
  UNKNOWN
  UNKNOWN_ONE_COMPONENT
  UNKNOWN_OTHER_COMPONENT
  UNKNOWN_VARIANT
  UNAUTHORIZED
}

enum RemoveInstitutionMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum RemoveInstitutionRepresentativeErrorCode {
  UNKNOWN
  LAST_OWNER
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
  UNKNOWN_REPRESENTATIVE
  UNKNOWN_USER
}

enum RemoveUserMethodDeveloperErrorCode {
  UNKNOWN
  UNKNOWN_METHOD
  UNKNOWN_USER
  UNAUTHORIZED
  UNKNOWN_DEVELOPER
}

enum RemoveUserRoleErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNAUTHORIZED
}

enum RequestUserPasswordResetErrorCode {
  UNKNOWN
}

enum ResendUserEmailConfirmationErrorCode {
  UNKNOWN
}

enum ResendUserEmailVerificationErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNKNOWN_EMAIL
}

enum ResetUserPasswordErrorCode {
  UNKNOWN
  INVALID_RESET_CODE
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum ResetUserTwoFactorAuthenticatorErrorCode {
  UNKNOWN
  UNKNOWN_USER
  DISABLING_FAILED
  RESETTING_FAILED
}

enum SetUserPasswordErrorCode {
  UNKNOWN
  UNKNOWN_USER
  EXISTING_PASSWORD
  PASSWORD_CONFIRMATION_MISMATCH
  PASSWORD_REQUIRES_DIGIT
  PASSWORD_REQUIRES_LOWER
  PASSWORD_REQUIRES_NON_ALPHANUMERIC
  PASSWORD_REQUIRES_UPPER
  PASSWORD_TOO_SHORT
}

enum SetUserPhoneNumberErrorCode {
  UNKNOWN
  UNKNOWN_USER
  UNCHANGED_PHONE_NUMBER
}

enum SortEnumType {
  ASC
  DESC
}

enum Standardizer {
  AERC
  AGI
  ASHRAE
  BREEAM
  BS
  BSI
  CEN
  CIE
  DGNB
  DIN
  DVWG
  IEC
  IES
  IFT
  ISO
  JIS
  LEED
  NFRC
  RIBA
  UL
  UNECE
  VDI
  VFF
  WELL
}

enum SwitchInstitutionOperatingStateErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
}

enum UpdateComponentAssemblyErrorCode {
  UNKNOWN
  UNKNOWN_ASSEMBLED_COMPONENT
  UNKNOWN_PART_COMPONENT
  UNKNOWN_ASSEMBLY
  UNAUTHORIZED
}

enum UpdateComponentErrorCode {
  UNKNOWN
  UNKNOWN_MANUFACTURER
  UNKNOWN_FURTHER_MANUFACTURERS
  UNKNOWN_VARIANT_OF_COMPONENTS
  UNKNOWN_GENERALIZATION_OF_COMPONENTS
  UNKNOWN_CONCRETIZATION_OF_COMPONENTS
  UNKNOWN_PART_OF_COMPONENTS
  UNKNOWN_ASSEMBLED_OF_COMPONENTS
  UNAUTHORIZED
  UNKNOWN_COMPONENT
}

enum UpdateDataFormatErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNAUTHORIZED
  UNKNOWN_DATA_FORMAT
}

enum UpdateDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_DATABASE
}

enum UpdateInstitutionErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_INSTITUTION
}

enum UpdateMethodErrorCode {
  UNKNOWN
  TWO_REFERENCES
  UNAUTHORIZED
  UNKNOWN_METHOD
}

enum UserRole {
  ADMINISTRATOR
  VERIFIER
}

enum VerifyDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_DATABASE
  WRONG_VERIFICATION_CODE
  REQUEST_FAILED
  DESERIALIZATION_FAILED
}

enum VerifyInstitutionErrorCode {
  UNKNOWN
  UNKNOWN_INSTITUTION
  UNAUTHORIZED
}

"The authorize directive."
directive @authorize("Defines when when the authorize directive shall be applied.By default the authorize directives are applied during the validation phase." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on OBJECT | FIELD_DEFINITION

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize("The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field." assumedSize: Int "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error." requireOneSlicingArgument: Boolean! = true "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields." sizedFields: [String!] "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments." slicingArguments: [String!]) on FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

scalar Any

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The NonNegativeInt scalar type represents a unsigned 32-bit numeric non-fractional value equal to or greater than 0."
scalar NonNegativeInt

scalar Url

scalar Uuid
